root > 리눅스에서의 관리자를 뜻함, 관리자 모드로 접속해야하는 경우 
root계정으로 접속해야함

스냅샷 > 복원시점 저장기능

유닉스는 판매할때 서버를 같이 판매함 > 현재 구입시 초기비용이 비쌈 (but 유지보수 비용은 free)

cent os > 레드햇의 소스코드 오픈버젼

리눅스 구성 3요소
커널 : 사용자가 원하는대로 하드웨어를 관리해주는 역할
쉘 : 사용자와 커널을 연결해주는 매개체 , 명령어 해석기 역할
디렉토리 (디렉토리 파일 시스템) : 파일을 어떻게 관리할 것인가를 결정하는 역할


bash shell : born agin shell 

centos > 5개의 가상콘솔을 지원하고있음 ctrl+alt f 1~5로 변경가능

cli  > command [option] [argument]
          명령어     옵션     대상
	띄어쓰기로 구분하며 대괄호 내용은 있을수도 없을수도있음

컨트롤 '-' : 창크기 줄이기
컨트롤 쉬프트 + : 창 크기 키우기
is -a /root

루트 사용자는 date 변경 가능함 > 시스템이 켜진 동안만 유지됨

whatis [명령어] : man -f 와 동일기능

write 사용자명 tty# (# : 터미널 넘버) > 메세지 주고받기기능 (root는 그냥 입력해도 가능)
ctrl +d로 취소
wall 메세지내용 : 모든 터미널에 메세지 내용을 브로드 캐스팅
who -w에서 +인경우 mesg y상태 -인경우 mesg n 상태임을 뜻함

useradd 사용자명 > 사용자추가
passwd 사용자명 > 사용자의 패스워드 설정

루트사용자가 보내는 메세지와 브로드캐스트 메세지는 거부 불가능(mesg n 상태여도 받을수밖에없음)

su - 사용자이름 > 사용자 전환
whoami 와 who am i 의차이점 > who am i 는 최초 접속한 사용자를 보여주고 whoami는 지금 터미널창에있는 사용자를 보여줌


shutdown -h의 기본값 : 1분뒤 종료

!u > u로시작하는 가장 최근에 사용한 명령어 사용

탭두번 입력 > 명령어로 쓸수있는 후보군을 보여줌

일반사용자들은 tmp나 home에만 파일을 만들수있다

run 디렉토리 > 메모리에 있는 파일들이 왔다갔다하는 경로

*경로의 구분
절대경로 : 무조건 / (루트디렉토리)부터 시작하는 경로
상대경로 : 현재 내 위치부터 시작하는 경로 
> ./ or . : 현재 디렉토리  ../ or .. : 상위 디렉토리

cd ~ : 현재사용자의 홈디렉토리로 이동
cd - : 이전디렉토리로 이동

#현재위치가 book/일때 코믹으로 이동하는경우
절대경로 cd /bob/comic
상대경로  cd ../../bob/comic

#현위치 /alice 이동위치 book 아래 ant
절대경로  cd alice/book/ant
상대경로 cd ./ book/ant
            cd  book/ant (./ 는 생략가능)

*주의 /root/는 / 아래에 존재하는 루트의 홈디렉토리임

#ls -a의 결과 값에서 파일 이름 앞에 . 이있는 경우는 숨김파일
ls -d 는 보통 -ld로 쓰임

alias : 특정 명령어의 별칭 지정가능 터미널이 켜져있는 동안만 동작함 (터미널이 닫히면 저장x)
.bashrc에 입력하면 영구적으로 설정가능 (설정파일변경)

하드웨어 > 커널이 관리함

리눅스에는 확장자를 기본으로 지원하지않는다

more과 less의 차이점 : less는 방향키와 페이지 업다운 검색이 가능함

tail -f  : 파일을 띄워두고 정보가업데이트되는 것을 확인가능
*tail -n +숫자  파일명 > (위에서부터 시작)해당열부터 끝까지보여줌 (+를 사용하려면 -n생략 불가능)

esc + '.' 이전에 입력한 주소를 그대로 불러옴

string : db파일과 같은 파일에서 우리가 읽을 수잇는 글자만을 보여줌

#wc  : wc 파일명 > 결과값 : 줄수 단어수 크기 파일명
wc -l 줄수 
wc -w 단어수
wc -c 파일 크기

#cp 복사대상 [생성하고자 하는 파일명] or [생성위치]
                   지정한 파일명 생성           복사대상의 이름과 동일
파일을 복사하는 경우 inode값은 변화한다

복사대상이 다수일경우
ex) cp 복사대상 1 복사대상 2 복사대상 3 복사대상 4  [현재 존재하고있는 파일을 생성할 디렉토리]
>이름은 그대로 들어감

#cp,rm,mv에서의 옵션설정
-i :덮어쓰기나 삭제에 대해서 대화형태로 진행
-f : -i 옵션이 있는 경우 대화옵션을 해제 (cp는 안되는 경우있음)
cp -a  : 복사하는파일의의 모든 속성을 가져오면서 복사함 (centos 8.0에서 안되는 경우있음)
cp로 디렉토리를 복사하는경우 안에있는 파일이 서로 다른경우 합쳐지게된다

#cp ~centos/f1  ./ : centos 에 있는 f1을 현재위치에 복사

#mv를 사용해서 옮기는 경우 사용자 소유권이나 inode값이 변하지않는다
mv는 이름을 바꾸는 용도로도 사용가능함, 디렉토리를 옮길때도 -r이 필요없음

#하드링크  :  원본파일과 이름을 제외한 모든값이 같은 파일 (i-node값이 같음)
인위적으로는 생성이 안되지만 하위 폴더가 생성될때마다 자동적으로 추가가된다

#심볼링크 : 파일이 가지고있는 이름의 경로를 기억한다 
(상대경로와 절대경로중 어떤것으로 설정하느냐에따라 성질이 바뀐다)

#하드링크나 심볼링크 중 어떤 값을 수정하더라도 
하드링크 파일은 만약 원본파일이 사라지면 원본파일을 대체함


 	파일 		                  디렉토리

r       cat,more,less                        ls, cp, tar(아카이브)
        head,tail,wc,grep                         find
        문서편집기(vim,gedit)      

w    문서편집기를 이용한 문서수정         생성, 삭제, 이동

x      명령어나 실행이가능한                   접근권한(cd가 가능)
      파일을 실행할수있음

*디렉토리에 대한 접근권한이있어야만 읽기나 쓰기가 가능함
소유자/루트는 권한상관없이 다 가능함

#more less 는 현재 터미널의 화면크기에 맞추어서 파일 내용을 출력함

#.bashrc > 개인 설정파일. alias등을 시스템이 종료되었다 다시켜져도 유지되도록 함

#mkdir -m > 디렉토리를 만들때 권한을 변경해서 생성할수있음

#자기가 속해있는 그룹의 소유권을 먼저 받는다

#chmod 에서 대문자X는 심볼릭모드에서만 가능하다

#grep -w : 단어 그자체만을 찾음 > 앞뒤로 다른것이 안붙어있는것만 찾음

#egrep : 여러개의 패턴을 찾을때 사용 '( 패턴1|패턴2)' 형태로 주로 사용
grep -e 를 사용해서도 가능함 > 각 패턴을 입력할때마다 -e 를 옵션으로 입력해줘야함
ex) grep -e 'i hate'  -e 'i love' -e 'you love' -e 'you hate' test

#fgrep : 앞이나 뒤에 정규표현식 특수문자가 있는 경우 일반문자 취급함
grep에서 패턴에 특수문자를 넣어야하는 경우 \(역슬래시)를 앞에 붙여주면 인식함

#grep에서 사용하는 [] 안의 내용은 오름차순만 인식한다 ex) a-z A-Z 0-9는 인식 z-a Z-A 9-0은 인식불가(에러발생)
[^a] :소문자 a를 제외한 모든 문자

#find는 자동적으로 하위디렉토리까지 탐색한다
find -type d: 디렉토리 f : 파일 l : 심볼릭링크

locate 명령어 >db에서 단어를 찾을때 사용하는 명령어


------vi/vim text editor 

명령모드에서 r R
r 누르고 다른 키 누르기 > 한글자에대해서 대체 입력가능(수정가능)
R 누르기 > replace 모드 집입 

dw > 단어삭제 스페이스(공백)와 특수문자를 기준으로 단어를 나눔
set hls is > 단어 찾기에서 하이라이트 설정
v와 대문자 v ,컨트롤 v: 비주얼모드와 비주얼 라인 

라인숫자 dd > 아래로 라인숫자만큼 지운다

------------------------------echo---------------------------------------- 
""는 일반적으로 특수문자를 일반 문자화시킨다 단 3가지 제외하고(``$\)
''는 모든 특수문자를 일반 문자화 시킨다
` 는 안에있는 명령문을 실행하여 실행결과를 대입.  $( ) 도 같은 기능을 수행함
('와 `의 구분을 잘 해야함)

echo의 사용용도 ex) echo "today is $(date)"  
echo 'today is $(date)'  > x  : 특수문자를 문자화시켜서 명령어를 입력하지못함

; 를 통해서 두개의 명령어를 같이 사용가능 (첫번째 명령어 ; 두번째 명령어)

명령어의 결과값을 파일내용에 추가하려면 > 를 사용함 (기존 내용을 지우고 결과값을 내용에 입력)

표준출력과 표준에러를 같이 파일로 저장하는 방법
&> 파일명 ( 덮어쓰기)
& >> 파일명(이어쓰기)
>파일명 2>&1(덮어쓰기)
>>파일명 2>&1(이어쓰기)

기존의 내용에 다른 내용을 추가하려면 >>를 사용

파일저장과 출력이 충돌하는 경우  : 
파이프라인 | 과 > 는 같이 쓰게되면 출력이 되지않는다 (내용저장은 된다) > | tee로 해결가능 

ex ) ls -R | grep 'Music' >R01 : 출력없이 저장 ls -R | grep 'Music' | tee R02 : 출력도 나오고 저장도 됨

사용예시 )  
ls -R / 2>/dev/null | tee fileb | grep 'bin' > 출력은 bin으로 걸러져서 나오지만 저장은 전부저장
ls -R / 2>/dev/null  | grep 'bin' | tee fileb > 출력과 저장 모두 bin이 걸러짐


---------------------------프로세스----------------------------------------------------------
프로세스 :  메모리에 올라가서 컴퓨터 cpu에서 실행되는 모든 프로그램을 일컫는 말

ps tree : 트리형태로 프로세스를 보여줌
ps -ef : 현재실행중인 모든 프로세스를 보여줌 (PID PPID TTY확인가능)
ps aux  : 현재 실행중인 모든프로세스를 보여줌 (CPU memory 사용량 PID 확인가능)
ps -l 


명령어 뒤에 &를 붙이면 백그라운드에서 실행함
jobs : 백그라운드 프로세스를 보여줌
fg %num : num번 백그라운드 프로세스을 멈춤

sleep n : n초동안 쉘스크립트를  멈춤 

signalnum : 짧은옵션 : 긴옵션
1 : -hup	-sighup
2 : -int 	-sigint
9 : kill	-sigkill
15 -term	-sigterm (def)
18 : =cont(컨티뉴)	-sigcont
19 : stop	-sigstop

PID : 운영체제에서 프로세스를 식별하기위해 프로세스에 부여하는번호
PPID : 부모프로세서의 PID를 의미 
만약 부모프로세스가 자식프로세스보다 빨리 종료되는경우 자식프로세스의 PPID는 1이된다

ps -ef 프로세스의 pid와 ppid를 확인할수 있음

kill -옵션  PI : 프로세스를 정지 종료 제거하는 명령어

pkill -f 프로세스명(혹은 일부) :  프로세스명을 검색하여 정지시킴 
(프로세스의 풀네임을 입력하지않아도 작동)

killall -9 프로세스명: 프로세스명을 검색하여 정지시킴 
(프로세스의 풀네임을 입력해야만 작동)

pkill -t 터미널 번호  프로세스명 > pts/0 의 sleep프로세스를 킬

nice -n nice값 프로세스 : -20~19까지 조정가능 , root사용자만 값을 줄일수있고 일반사용자는 증가만가능
renice nice값 [옵션] pid : 실행중인 프로세스의 nice값 변경, root사용자만 값을 줄일수있고 일반사용자는 증가만가능

----------------------------아카이브------------------------------------

아카이브 : 원래 뜻은 보관소/저장소.
리눅스에서의 아카이브 : 파일을 묶어서 하나로 만든것. 즉 압축파일

형식 : tar 옵션 아카이브명 

tar : tar cvf file.tar [argument(대상)]
gzip : tar zcvf file.tar.gz [argument(대상)]
bzip2 : tar jcvf file tar.bz2 [argument]
xz : tar Jcvf file.tar.xz [argument]

명령어를 이용한 압축      해제방법        	해제방법2
gzip file                       옵션에  -d		gunzip
bzip2 file                     옵션에  -d		gunzip
xz file                          옵션에  -d		gunzip
> 간단하다 but 디렉토리 압축 불가능(파일만가능). 압축을 하는 순간 원본파일이 사라짐
압축을 해제하는 순간 기존 압축 파일 사라짐


아카이브는 무조건 상대경로로 만들어야 함 > 절대경로로 설정하면 tar 안에 절대경로와 동일한 하위디렉토리를 만듬

*주의* 아카이브의 압축을 풀때는 현재경로에서 시작함 
ex ) 
root에 dir1,2를 만들고 dir1에는 01~20의 파일을 생성한뒤 dir2에 아카이브생성
mkdir dir{1..2} touch dir1{01..20}
dir1/{01..20}    tar cvf dir2/num.tar dir/{01..20}

1.root에서 압축을 푸는 경우
[root@localhost ~]#tar xvf dir2/num.tar   >  루트에 dir1이 덮어쓰기됨 
(만약 압축을 풀기전 dir1이 사라져있다면 새로 생김)

2.dir2에서 압축을 푸는경우
[root@localhost dir2]#tar xvf num.tar > dir2 내에 dir1이 생기고 그안에 압축되었던 파일이 풀림

아카이브파일은 파일의 권한 경로 등 여러가지값들이 모여있음 > 원래 파일보다 크기가 커질수있다

아카이브 파일 형식

gzip >  bzip2   > xz  : 갈수록 속도는 감소하고 압축률은 증가함


tar xf 아카이브파일  -C 다른경로 : 다른경로에 압축을 풀고싶을경우 사용

-----------------------------------------------------------------------------------
echo $HOME : 홈디렉토리 경로를 담은 환경변수

echo $PATH : 환경 변수들의 경로를 보여주는명령어, ' :  '으로 구분되어있다 
명령어를 입력시 환경변수에 잡혀있는 PATH를 따라가서 해당파일이 실행되는 원리

wheel 그룹 : 관리자 권한을 대행하는그룹. wheel그룹에 추가된 사용자 외에는 su나 sudo의 명령어 접근제한

sudo 명령어 입력시 암호입력필요 > /etc/sudoers 파일을 수정하여 바꿀수있다


useradd

-D : default > /etc/default/useradd의 내용확인 또는 변경
*/etc/default/useradd의 내용설정
group 100 > 사용자를 새로 만드는 경우 사용자의 이름과 같은 그룹을 새로 만들어 신규사용자 혼자만 속하게됨
100이 기본값 
home=/home  
INACTIVE=-1 > 값이 음수일경우 설정x 패스워드의 사용기간이 지난뒤 계정로그인을 막는 유예기간
0은 유예기간 없음 3 : 유효기간지난후 3일 이내는 로그인가능
SKEL=/etc/skel> 사용자생성시에 제공되는 파일 및 디렉토리가 들어있는 디렉토리

-u : uid 커스텀생성
-g : gid 지정 (기존에 존재하는 그룹에 대해서만)
-G : 보조그룹 지정
-c : 코멘트 생성
-d : 홈디렉토리 커스텀 생성, 최종경로만 생성하므로 중간경로는 미리 생성필요
-m : /etc/login.defs  안의 CREATE_HOME 항목이 no로 되어있는 경우 홈디렉토리를 만들고 싶을 때 사용
(-d옵션과 같이 사용함) make의 의미
-s : 로그인쉘 지정 (/sbin/nologin 은 서버로의 로그인이 필요치않는 계정일 경우에 지정)

>-d 옵션과 -b옵션은 결과가 다르므로 주의 
ex) -d /home /user02로 설정 > /home/user02
-b /home/user02로 설정 > /home/user02/user02

>uid를 설정하지않고 유저를 추가하는경우 uid값은 이전사용자가 가진 값의 다음값이 된다

user를 추가한뒤 /etc/passwd에서 정보를 확인가능 ex) tail -2 /etc/passwd

#디폴트값의 홈디렉토리수정시에는 -b를 사용
-홈디렉토리를 지우고 다시생성하는 경우
cp -r /etc/skel 홈디렉토리 경로
chmod 700 홈디렉토리
chown 사용자 : 그룹 홈디렉토리

usermod 대부분 useradd의 옵션을 거의 다 사용가능
단 -m 옵션의 경우는 내용이 다름 
usermod -m : 홈디렉토리를 수정할 경우에 실제로 홈디렉토리에 대한변화를 주기위해서 사용 (-d옵션과 같이 사용 move의 의미)
-a :보조그룹을 추가할때 사용 (-G만 사용할 경우 추가가아닌 대체가 됨)
-L :계정 잠금
-U : 계정 잠금 해제

userdel : 유저 삭제 -r을 붙여야 홈디렉토리까지 전부 삭제함

chage : 암호속성을 확인 및 수정

groupadd -g 10 그룹명 > gid 값10인그룹 생성 이미 10의 gid를 가진 그룹이 있는경우 -og를 사용해서 추가가능
groupdel같은 gid 값을 가진 그룹이 있는경우 그룹 삭제시 오류가 생길수 있음  > gid값을 바꾸면 해결가능

그룹설정값확인 : /etc/group

setuid : 실행파일에 적용하면 root권한을 주지않아도 root의 권한으로 파일실행가능
ls -l 로 확인시 소유자 실행권한쪽에 s로 표기
ex) cat명령어에 setuid를 주면 다른 사용자가 해당명령어를 사용하여 루트의 내용확인가능

setgid : 디렉토리에 설정되어있으면 이 디렉토리에 새로 설정된파일들은 디렉토리의 그룹소유권보다
파일 생성자의 그룹소유권을 얻게됨
ls -l 로 확인시 그룹 실행권한쪽에 s로 표기

sticky bit : 해당 디렉토리에 생성한 파일의 삭제를 관리자와 파일소유주만 할수 있도록함
ls -l 로 확인시 기타 사용자 실행권한에 t로 표기

8진수 값
setuid : 4000
setgid : 2000
sticky bit : 1000

다른 값들과 같이 여러개를 동시에 설정이 가능함 ex) +7000 +6000 ...
대신 해제시에는 하나씩 풀어내야 해제가 가능
----------------------------------ACL-------------------------------------

chmod를 사용하면 하나의 사용자와 하나의 그룹만이 읽기쓰기실행권한을 가질수있음
acl 을 사용하면 여러 명의 사용자와 그룹도 권한을 가질수있다

acl mask : 모든 특정사용자나 그룹에 허용되는 최대 유효권한 사용

디렉토리단위로 default ACL을 지정가능 
> 해당 디렉토리의 하위에 있는 파일이나 디렉토리는 설정된 default ACL을 따르게된다
(해당디렉토리는 해당 x 하위 디렉토리부터 적용됨)

ls -l 에서 권한표기 맨뒤에 +로 표기됨

--------------------------예약----------------------------------------------
at :1회성 작업예약 
time spec : 특정시간을 문자열로 지정한것  /usr/share/doc/at-3.1.13/timespec에서 확인가능
ex) teatime : 16:00 noon : 12:00
at은 화면출력기능이없음 > 대신 메일을 통해서 출력결과를 보내게됨

at now +시간
예약할 내용 입력
컨트롤 d
at -l or atq > 예약된 작업내용 확인가능
at -m > 메일로 작업내용을 보냄
at -c 작업번호 : 해당작업번호 수행
atrm 작업번호 : 해당 작업번호 삭제


cron : 주기적인 작업을 예약시 사용,
crond 데몬에의해 관리 , crontab 명령어에 의해서 작업등록
corntab 또한 출력기능이없음 > 메일로 오게됨

형식 : crontab [ -u 사용자 id] 파일
루트사용자만이 다른 사용자의 파일에 접근이가능

*cron의 동작 방식
모든곳에 저장된 설정파일을 읽어 메모리에 저장하고 휴지상태에 들어감
> 매분마다 활성화되어 변경된 crontab파일이있는지 확인하고 변경시 다시읽어저장하고
그시간에 실행할 작업이있는지 확인하고 실행후 다시 휴지상태 돌입

사용자크론 : crontab
시스템 개별사용자 : /var/spool/cron/사용자이름 에 작업 내용이 저장됨 
일반사용자는 crontab을 볼수없음 > 루트사용자만 볼수있음
root계정용 하나 계정 사용자당 1개의 파일을 가짐 사용자별로 각 1개의 파일을 가짐

시스템 관련 작업 : /etc/crontab을 이용해서 etc/cron.d/에 저장해서 사용가능
쉘이나 다른 여러 설정을 변경가능
time spec / 사용자이름  / 명령어 형식으로 사용
시스템크론 : 따로 etc/에 cron.hourly, cron.monthly 등으로 존재

ex) 22 4 * * 0 root run-parts /etc/cron.weekly으로 사용가능
>매주 4시 22분에  /etc/cron.weekly내에 있는 스크립트실행


corntab -l 작업나열
corntab -r 모든작업 제거 > 하나만 지우고 싶은 경우 편집파일 들어가서 하나만 지워줘야함
corntab -e 편집 vi 편집기 형태로 입력
corntab -파일이름 
crontab -u 사용자명 옵션 > root사용자만 사용가능

cron timespec 구성
분	시	일 	월 	요일 	명령어
0~59    0~23      1~31      1~ 12      0~7
		          (약식월)    (약식요일 mon~sun)

> /etc/corntab을 통해 확인가능 time spec은 교집합

time spec 특수문자 
* : 모두참
/ : 주기
- : 범위
, : 항목

anacron : 시스템이 꺼져있더라도 예약작업이 수행이된다


----------------리눅스 파일 시스템--------------------------------------

hdd구조 
여러개의 섹터가 모여서 트랙을 이루고
트랙이 옆으로 쌓여서 하나의 플레이트를 이룸
플레이트가 세로로 쌓여서 실린더를 형성

*리눅스에서는 섹터의 개수를 가지고 디스크의 용량을 정한다

hdd의 연결방식의 변화  IDE방식 > SATA방식,SCSI > ...

리눅스의 하드디스크 형식 
IDE방식(HD) 100mb > SATA방식,SCSI,USB (SD)> (VD) : virtual disk
ex ) SD a , SD b ... 
파티션 만들경우 > SD a1 SD a2 ....

*핫플러그기능 : 시스템이 꺼지지않은 상태에서도 하드디스크를 연결가능함
SATA2부터 가능해짐

lsblk  : 디스크 확인 명령어
sr0 : 일반적으로 dvd장치
디스크들은 : dev/에 들어있음 type : b
핫플러그 기능은있지만 따로 스캔할수있도록 명령어 입력필요 >echo ' - - -' > /sys/class/scsi_host/host0/scan
host:  디스크와 논리적으로 연결된 채널 , 일일이 확인해야함 > 쉘 스크립트를 작성해서도 실행가능
du 디렉토리 : 해당디렉토리의 사용여부 및 용량을 보여줌

파티션 방식 
파티션구성방식 :  MBR GPT
디스크하나에는 하나의 파티션방식만 가능함

MBR : 1980년대 생겨난 방식 주(Primary) 파티션 - 4개 or 주 파티션 3개+확장 파티션 1개로 구성
*주파티션 : 부팅이 가능한 파티션을 말함
확장파티션 : 논리파티션을 설정할수 있는 공간을 확보해주는파티션 (일반적으로 논리파티션은 11개까지 가능)
> 하나의 확장파티션안에 여러개의 논리파티션으로 구성가능, 실제로는 하나의 확장파티션으로 인식
인식용량이 최대 2TB까지만 가능
파티션의 정보를 담은 MBR table이 앞에 붙어있다

GPT : 1990년 후반에 생겨난 방식 
이론적으로는 무한대로 파티션이 가능.
but 실제적으로는 주 파티션 128개까지가능 (확장파티션이나 논리파티션이라는 개념 x)
최대 인식용량 : 8zb 까지 가능 (b-kb-mb-gb-tb-pb-eb-zb) 1zb = 10억 tb
파티션의 정보를 담은 MBR table이 앞,뒤에 붙어있다

*파티션을 만들때 파티션끼리 겹치거나 공백이 생기지 않도록 주의할것
겹치면 데이터 깨짐, 공백이생기면 공간이 낭비됨

*dos : disk operation system

리눅스에서는 xfs ext4를 주로 사용

blkid : 포맷을 했을때 장치명(UUID)을 알려주는 명령어
df -TH(mb,gb), df -Th(mib,gib)

fdisk - MBR 파티션
gdisk - GPT 
parted -MBR/GPT
교재 -333p ~426p

fdisk /dev/sb[x] 
새로운 파티션을 만들때 MBR테이블때문에 2048번 섹터 부터시작
3개의 파티션을 만들면 디폴트값이 e (extended)로 바뀜
extended파티션을 지우면 안의 논리파티션이 모두 지워짐
논리파티션은 5번부터시작


partprobe /dev/ 파티션을 만들고 입력해줘야 파티션 인식
gdisk 에는 hex code뒤에 00이붙는다 (4자리)

파티션 방식을 바꾸는 경우 o 나 g을 사용해서 다른방식의 파티션으로 
생성해야한다

포맷명령어 : mkfs -t(type) 포맷형식  파티션명 or mkfs.포맷형식 파티션명

vi /etc/fstab > 영구적인 마운트 설정
파일구성
     장치명 (UUID)/ 마운트 포인트/파일시스템 /옵션 /덤프유무/ 파일시스템 체크순서(부팅순서)
ex)  /dev/sdb1     /mnt/disk1       ext4      defaults  1              1
> 옵션들이 하나라도 잘못되면 부팅시 에러 발생( 특히 defaults주의)
기본시스템을 제외한 다른설정을 추가하는 경우 덤프유무와 파일시스템 체크순서는 1이상으로 잡아줌

장치명 : 반드시 파일시스템이 포맷되어있어야함 uuid로 대체가능

마운트 : 디스크에 접근할수있는 통로를 열어주는것 
디스크를 연결하면 특정위치에 마운트하여 사용하는 형식 > 마운트하지않으면 접근이불가능

마운트포인트 : 미사용중인 디렉토리어야함 (기존파일들은 마운트 해제 전까지 사용할수없음)

mount -a > /etc/fsatb 에 올라가있는 설정을 다올림
umount -a >  /etc/fsatb 에 올라가있는 설정을 다올림 , 단 사용중인것은 내릴수없음
umount시 해당디렉토리에 위치하고있으면 사용중으로 마운트해제가 안됨


*순서기억할것  파티션 나누고(fdisk/gdisk) > 포맷한뒤에(mkfs.xxx/mkfs -t ) > 마운트 (mount 장치명)

---------------------------------------swap---------------------------------------------------------

swap : 물리적디스크를 가상메모리처럼 사용하는 기능
포맷형식을 swap으로 설정해줘야함

/etc/fstab 에 옵션을 적을때 오류가 나더라도 크게 영향은 없음
swap설정시에는 덤프유무와 부팅순서는 0 으로 주는 편 ( 부팅시 메모리가 확보되면 성능향상이 가능하므로)

/etc/fstab에 올리는 경우 swap의 형식 > 장치 경로 swap swap defaults 0 0

swapon 장치명 : 해당장치를 swap으로 사용
swapon -s  : 현재 swap설정된 내용 확인
swapon -a : /etc/fstab 에 입력된 swap내용 올리기

swapoff 장치명 : 해당장치를 swap에서 사용해제
swapoff -a  : /etc/fstab 에 입력된 swap내용 전부 내림

mkswap 장치명 : 스왑으로 파일시스템 포맷

---------------------------------------LVM-----------------------------------------------------

logical volume manage 

여러개의 하드디스크를 합쳐서 하나의 파일시스템으로 사용
*RAID의 개념과 유사 > LVM로도 RAID를 구축가능

디스크 용량/ 제조사 /형식이 모두 같아야함
RAID 0 - span, stripe > 2개의 디스크를 합쳐서 한꺼번에 사용하는 방식
span 과  stripe의 차이점 
: span > 쌓는다. 두개의 디스크를 세로로 쌓아서 하나의 큰 디스크를 만드는것
stripe > 2개이상의 디스크를 가로로 합쳐서 하나의 디스크 처럼 사용하는것
안정성대신 성능을 택하는것

RAID 1 - mirroring  > 데이터를 기록할때 서로다른 두개의 디스크에 같은 데이터를
기록함  안정성좋음

RAID 5 - parity 사용 최소 3개의 디스크가 필요하며 기록되는 데이터의 parity bit를 만드는 방식
 데이터의 복원을 하는데 필요한 parity bit를 기록하는 방식

RAID 10 - 선 미러링 후 스트라이프
RAID 01 - 선  스트라이프 후 미러링 > 복원시에 10보다 복잡함


물리 볼륨 (Physical Volume)  : 파티션
볼륨 그룹 (Volume Group) : 물리볼륨을 합쳐서 1개의 물리그룹으로 만드는것 
논리 볼륨 (Logical Volume) : 볼륨그룹을 1개이상으로 나누어 논리그룹으로 나눈것

> 여러개의 물리 볼륨을 묶어서 하나의 볼륨그룹으로 만들고
그 볼륨그룹을 여러개의 파티션(논리볼륨)으로 나누어서 사용한다
*lv는 특정 물리 파티션에 속하는것이 아님 

논리볼륨 : 이름지정이 사용자지정으로 가능하고 확장필요시 사용중에도 명령어를 이용해 확장가능
최소단위 > PE(LE) 기본 4mib

PE 가 클수록 데이터를 처리하는 속도가 빠르지만 낭비가 심함
작을수록 효율적으로 사용이가능하지만 속도가 느림

pvcreate 장치명/파티션명
vgcreate 볼륨그룹명 장치1 장치 2... 
lvcreate 볼륨그룹명 옵션 용량

pvdisplay - pv지정 설정 확인명령어 (vgdisplay/lvdisplay)  -v (내용을 더 자세히 출력)
PE크기 변경 vgcreate 볼륨그룹명 장치1 장치 2... -s PE크기 (4의 배수로올림 다른숫자도 가능하긴함)
vgcreate vg1 /dev/sdb[24] -s 8 > 만들때 설정해야함 (이미 만들어진것은 바꿀수없음)
pv가 없는 상태에서 만들어도 자동적으로 pv를 생성하여 vg를 만든다

lvcreate 그룹명 -L 실제용량 > lvcreate vg0 -L 2G -n lv01

lvcreate 그룹명 -ㅣ 실제용량(LE개수)  > lvcreate vg0 -l 512 -n lv02

ls -l /dev/vg0/lv01 /dev/mapper/vg0-lv01
> lv생성시 두가지 경로가 생기고 둘중 어느 경로를 사용해도 관계없음
(시스템은 임의로 둘중하나를 선택하여 사용함)

lvcreate vg1 -l 100%FREE -n lv05 볼륨그룹에 있는 나머지 용량을 다꺼내서 쓰겠다

lv 삭제시에는 반드시 마운트 해제후 삭제해야함

lvremove 그룹명 장치명
vgremove 그룹명
pvremove  장치명

볼륨그룹 확장 : vgextend vg명 pv명...  > pv가 아닌경우 자동으로 pv로 변환된 후에 확장됨
볼륨그룹 축소 : vgreduce vg명 pv명...
물리볼륨 내용 이동 : pvmove pv명...

lv 확장시에 -r을 써주지않으면 실제 디스크 크기만 늘어나게된다
>파일시스템의 크기는 늘어나지않으므로 그대로인것처럼 보임
lsblk에서는 확장된것으로 보이지만 df -Th에서는 확장되어있지않음 
명령어를 사용하여 따로 파일시스템을 확장시켜주어야함

논리볼륨 확장 : lvextend lv경로 -r(파일시스템 확장)
xfs  파일시스템 확장 : xfs_growfs 마운트 포인트
ext4 파일시스템 확장 : resize2fs lv경로
swap인경우에는 사용은가능하지만  확장이 불가능  > swapoff시킨뒤 다시 swapon으로 진행

pvmove pv명 > 해당 pv의 데이터를 볼륨그룹의 나머지에게 재할당시킴

*vg내에 존재하는 한 파티션을 제거하는방법(pv로 설정되어있음) 제거시 순서

1.vg내에 현재 pv의 데이터를 옮길만큼의 용량이 남아있는지 확인

2.만약 디스크내에 충분한용량의 파티션이 남아있으면 그것을 사용
충분한용량이 없는경우 같거나 더 큰 용량의 디스크를 추가하기

3.추가한 디스크의 파티션을 추가한뒤 pv로 만들고 vgextend 로 vg에 포함시키기

4.pvmove를 사용하여 삭제할 디스크내의 lv를 같은 vg상의 다른 pv로 옮기기

5.vgreduce를 사용해 삭제할 디스크를 vg에서 제거한뒤  pv제거

6.fdisk를 사용하여 해당 파티션을 제거하고 partprobe 수행한뒤 확인

lvreduce : 존재하긴하지만 쓰지않는것을 권장 > 파일시스템을 줄이기전 lv를 줄이면 파일시스템이 깨짐
리눅스는 파일을 처음부터저장하는것이아닌 각가지로 저장하기때문

디스크를 교체해서 데이터를 옮기는 경우 기존 디스크보다 크기가 같거나 커야만 한다


------------------------------systemd--------------------------------------------------

systemd : 레드햇 부터 나온 1번 프로세스 (PID 1) init 프로세스의 대체 (ps -ef로 확인가능)
이후에 ubuntu를 사용할때에도 사용가능

위치 : /usr/lib/systemd/system(원본),  /etc/systemd/system(시스템이 부팅이 될경우에 설정되는 부분),  /run/systemd/system ( 실시간으로 돌아가는 데이터들이 있는곳)


systemctl list-units = systemctl 
systemctl list-units -t service (systemctl list-units --type=service) 서비스 목록보기
systemctl list-units -a -t service 실행되지않은 모든서비스를 포함한 목록 보기

systemctl list-unit-files 설치된 모든 유닛 파일 보기

systemctl list-dependence 서비스 이름 : 종속성 확인
서비스가 실행되려면 사전에 어떤것들이 실행되어야하는지 트리 형태로 보여줌

enabled > 부팅시 자동으로 실행 
diabled > 부팅시 자동으로 실행 x 수동으로 실행가능
static > 자동으로 실행하지않지만 다른 유닛에 의해서 실행될수 있도록 대기
masked > 아예 실행이되지않도록 락을 걸어둔것

systemctl status 서비스이름 > 해당유닛들에대한 정보를 알수있는 명령어


*systemctl start/stop/restart/reload/enable/

systemctl restart : 서비스를 메모리에서 내렸다가 다시올림(재시작) > PID값 변화
systemctl reload : 서비스를 끄지않고 설정값을 적용  PID값 변화x

systemctl enable : /etc/systemd/system내에 심볼링크 추가 > 부팅시에 시작됨
systemctl disable : /etc/systemd/system내에 존재하는 심볼링크를 제거
> 부팅시에 서비스를 시작시키지않겠다는 메세지

systemctl mask : /etc/systemd/system내에 /dev/null로 이어지는 심볼링크를 추가시킴
아예 시작 조차 불가능하게 만듬

systemctl unmask : mask 해제

*소프트웨어를 설치했다면 enable시킨뒤 start를 해주어야만 작동가능

------------------------------log-----------------------------------------

log : 시스템에 일어나는 이벤트들에 대한기록
이슈발생시에 해당시간에 일어났었던 모든일에 대해서 파악하기 위한 제1수단

/var/log : 일반적으로 로그저장되는 위치

로그를 관장하는 서비스 : systemd-journald ,  rsyslogd	

systemd-journald : 로그를 수집하는 역할 (/run/ 에서 수행 > 메모리에서 수행)

rsyslogd	: 로그를 저장하는 역할 ( /var/에서 수행)

var/log/messges > 대부분의 로그가 여기 기록
BUT 인증 이메일 정기적 작업 부팅관련 및 디버그메세지 제외

var/log/secure : 보안 및 인증 관련 메세지 및 오류 관련로그

var/log/cron : 반복적인  예약 작업에 대한 로그

var/log/mailllog : 메일 관련된 로그

var/log/boot.log : 부팅관련 로그

#(facility)기능.(priority)우선순위에 의해서 저장이 이루어진다
> /etc/rsyslog.conf에서 확인 및 설정가능 
(따로 새로운 로그를 설정하고 나면  반드시 rsyslog.service를  재시작해주어야 제대로 동작 )
cron.alert   /var/log/cron > cron에 관련된  alert 이상의 로그 ( emergency)를 /var/log/cron에 기록하겠다
cron=alert   /var/log/cron > cron에 관련된  alert로그만을 /var/log/cron에 기록하겠다
cron.*   /var/log/cron > cron에 관련된  모든로그를 /var/log/cron에 기록하겠다
>수정한 뒤에는 rsyslog서비스를 재시작해주어야 적용됨

-facility : 발생되는 메세지의 종류
authpriv : 인증
cron : cron, at과 같은 스케줄링
deamon : telnet, ftp 와 같은 데몬서비스
kern : 커널
mail : 메일 ( - 가 붙어있음 > 데이터를 메모리버퍼에 쌓아두다가 어느정도 디스크의 여유가생기면 기록하라)
local1-8 : 부팅
lpr : 프린트
mark : syslog에 의해 만들어지는 날짜유형
user : 사용자
auth, security : login 

-priority  : 지정된 우선순위보다 높은 값(숫자가 낮은값)을 모두포함
0~7까지 존재, 숫자가 작을수록 심각한 단계
수정시에 앞에 등호를 붙이면 해당 우선순위값만 저장
0 emerg > 터미널 입력 화면에도 자동으로 출력됨
1 alert
2 critical
3 error
4 warning 
5 notice
6 info
7 debug

tail -f 로그파일 : 로그파일이 변하는것을 실시간으로 확인 가능함
logger -p (기능).(priority)  "메세지": 실시간으로 로그를 발생시키는 명령어

systemd-journald:  journalctl로 확인가능 분류하지않고 모든 기록이 다되어있음
journalctl -p 우선순위로 특정 우선순위 이상의 것만 확인가능
journalctl -f : tail -f 와 동일기능
journalctl -n 숫자 : 최근내역에서 숫자만큼 출력
journalctl --since yyyy-mm-dd  : 해당날짜부터 현재까지출력
journalctl --since yyyy-mm-dd --until yyyy-mm-dd  : from since to until 출력
journalctl -r : 역순으로 정렬

우선순위 notice 이상인경우 굵은글씨 error이상이면 빨간글씨로 나옴
(debug/info > 일반메세지 notice/warning > 볼드체 error/critical/alert/emerg > 빨간글씨)


-로그파일 순환
로그가 쌓이면 공간을 많이 차지하기때문에 logrotate라는 유틸리티로 순환
로그가 순환되면 순환된 날짜를 나타내는 확장자가 포함된이름으로 변경

로그파일이 순환되면 새로그파일이 작성되고 기록시작 일정순환이후에는 폐기
cron작업은 logrotate를 매일실행하여 순환이 되는지 확인

*/run/log/journal 영구저장
var/log/journal 을 만들고 소유 그룹을  systemd-journal 로 한뒤 setgid설정
systemctl restart systemd-journald > /run/log/journal 의 내용을 var/log/journal 로 옮길수있음
(시스템을 껏다켜도 증발하지않는다)
단 사이즈가 현재 파일시스템의 10%이상이 여유공간의 15%를 넘으면 안된다

-------------------------부트 시스템 ----------------------------------------------------

-부트 프로세스-

1. 시스템 전원 on

2. bios 프로그램 실행 > POST

3. 부트매체 검색 >CMOS에 설정되어있는 순서대로 부팅을시도
MBR(GPT도 가능 : 바이오스 환경에 따라서 바뀔수 있다)에 존재하는 부트로더인 GRUB을 읽어
부트로더가 메모리에 적재되고 시스템 제어권은 부트로더가 가지게 된다

4. 부트로더가 커널을 메모리에 올리고 커널이미지를 불러들이며 커널에게 시스템제어권을 넘김

5. 커널 부트이미지를 적재 > 커널목록중에 사용할 커널을 선택하면
커널이미지가 동작 > 커널이미지는 압축되어있어서 PID 0번 swapper프로세스 호출
swapper프로 세스는 커널이미지 압축해제하고 커널이 사용할 각 장치들을 초기화하고 정보를 
콘솔에 출력함

6. 루트 파일시스템 마운트 
하드웨어 검색이후 커널은 루트 파일시스템을 마운트 
( 안전하게 점검되도록 읽기전용으로 마운트함 /sysroot : 점검을 위한 루트디렉토리)
이후에 읽기/쓰기로 마운트가 이루어짐

7. systemd 프로세스를 실행
모든 프로세스의 부모역할인 PID 1번 systemd 프로세스 실행>default.target 유닛 불러들임
> 사용자가 시스템을 사용할수 있도록 시스템 초기화 진행 (local-fs.taget을 통해 파일 시스템점검)
> 이후 sysinit.target을 시작으로 필요한 스크립트를 통해 커널 모듈의 메모리 적재
스왑파티션 초기화 / 네트워크초기화/ 서비스 프로세스 관리/ 가상콘솔 접속관리 / 실행레벨 관리 실행

*바이오스 관련 용어
1. 레거시 : mbr 파티션 형식 2TB이상 대용량 HDD에서 문제점이 발생
2. UEFI : gpt 파티션 형식 GUI인터페이스 제공 빠른부팅가능(하드웨어 진단을 건너뜀)
2TB이상 고용량 HDD제어 가능
3.CMOS : 컴퓨터에서 NVRAM의 역할 bios정보가 저장되어있고 이를 불러올때 사용됨


POST : power on self test
부팅시 컴퓨터가 자체적으로 하드웨어들을 검사하는것

runlevel/target : 
runlevel : 시스템의 상태를 7단계로 정의하고 각단계에 따라 셸 스크립트를 실행
target : centOS7부터는 systemd 프로세스를 사용하는데
systemd프로세스는 런레벨을 target이라는 유닛으로 변경하여 사용한다

		리눅스 6               리눅스 7
프로세스 		init 		  systemd
시스템상태 표시	Runlevel 		  target

ls -l  /usr/lib/systemd/system/ | grep "runlevel"을 런레벨들이 타겟에 대응되어있는것을 알수있다

runlevel 정리 
0 poweroff
1 rescue : 시스템 복구모드 (단일사용자모드
2┐ (사용하지 않지만 호환성을 위해 런레벨 3과 동일취급)
3 - multi-user : 텍스트모드의 다중 사용자 모드
4┘ (사용하지 않지만 호환성을 위해 런레벨 3과 동일취급)
5 graphical : 그래픽모드의 다중 사용자모드 
6 reboot

sytemd 프로세스는 default.target를 불러들이지만 종속성에의해서 아래 타겟들이 실행됨
(순서대로 종속되어있음 > graphical 을 실행하기위해서는 multiuser실행되어야함)

1.local-fs.target : /etc/fstab 불러옴(마운트)
2.sysint.target : 시스템 마운트, 스왑, 커널의 추가 옵션을 실행하는 서비스 시작
3.basic.target :  firewalld, microcode, SELinux 등 보안관련 서비스 및 커널 메세지와 관련된 서비스를
	        시작 및 로드
4.multi-user.target  : CLI환경으로 부팅, 서버에서 사용되는 모든서비스를 불러들임
5.graphical.target : gui모드로 부팅

*emergency.target : 시스템 부팅중 발생한 문제에 대한 해결용도로 사용
최소한의 환경을 제공하는 긴급쉘 제공, 루트파일 시스템(/)이 읽기 전용으로 마운트
파일 내용을 수정할경우 읽기-쓰기로 다시 마운트

rescue.target : 단일 사용자환경을 제공하는 복구쉘을 제공
루트 파일 시스템(/)이 읽기-쓰기로 마운트됨
네트워크 인터페이스 비활성화

who -r or runlevel : 현재 기본부팅설정을 런레벨로 확인
ls -l /etc/systemd/system/default.target, 
or systemctl get-default 현재 기본 부팅 설정 확인
systemctl set-default multi-user.target  현재의 기본 설정을 멀티유저 타겟으로 변경 
systemctl isolate <target>  > 재부팅 하지않고 타겟만 전환시킴
기본설정이 변화하지않고 일시적으로만 가능 > 전원이꺼지면 원래대로 돌아옴


부트로더 : 운영체제가 시동되기전 미리실행되면서 커널이 올바르게 실행되기위해
필요한 모든 작업을 마무리하고 최종적으로 운영체제를 시동시키기위한 목적을 가진 프로그램
centOS7은 GRUB2를 부트로더로 사용중임

*커널 : 하드웨어와 프로세스를 있는 핵심 인터페이스

GRUB : GNU에서 만든 부트로더를 뜻함

root 비번 변경

커널선택 화면에서 아무키 눌러서 카운트 해제
원하는 커널에서 'e'눌러서 grub 진입
linux16 라인 끝에 rd.break 입력 후 ctrl+x

mount -o rw,remount /sysroot > 읽기 쓰기로 재마운트
(리눅스 os 부팅시 /sysroot에 passwd 명령어가 보관되어있음
해당 /sysroot 디렉토리는 읽기권한만 지정되어있어서 임시로 쓰기권한부여를 위해 재마운트)

chroot /sysroot >  /sysroot를  루트 디렉토리로 인식하게 만드는 명령어
passwd
touch /.autorelabel > 부팅시 파일의 SELinux 컨텍스트 변경을 확정하기 위해 사용
                            SElinux 가 부팅시에 이 파일을 보고 라벨을 재지정함
		    (바꾼 설정이 적용됨, 부팅시 자동 삭제됨)
ctrl+d
ctrl+d

부트로더 커널 이미지 시간 

vi /etc/default/grub

GRUB_TIMEOUT=5 => 5를 다른 숫자로
:wq


부트로더 ID 및 PW 설정

vi /etc/grub.d/00_header

G를 눌러 제일 마지막 부분으로 이동

o를 눌러 편집모드로 들어가서 해당 부분 작성

cat << EOF
set superusers='ID명'
password ID명 PW
EOF
:wq

설정내용 부트로더 인식

grub2-mkconfig -o /boot/grub2/grub.cfg 
reboot

-런레벨로 시스템상태 설정
init 런레벨  

------------------------------소프트웨어 추가/제거----------------------------

패키지 : 리눅스에서 소프트웨어를 말함  이름.rpm 형식

RPM : Redhat Pakage Manger 저수준의언어(기능적으로 적음)
종속성을 해결하지못함

릴리즈번호 > 어느 리눅스 버전에 사용가능한지 표기


rpm 명령어
1.패키지 정보확인 명령어 (설치되어있는 것들만 볼수있다)
-q (쿼리)
	-qa  : 시스템에 설치되어있는 모든 패키지
	-qi 패키지명 : 패키지에 대한 정보
	-qc 패키지명: 패키지의 설정파일들을 보여줌
	-qd 패키지명 : 패키지의 문서를 보여줌
	-ql 패키지명: 패키지의 모든 파일 보여줌
	-qf 파일명 : 해당 파일이나 디렉토리가 어떠한 패키지로 인해서 파생되어있는지 알려줌

2.패키지 설치 및 업데이트 ( 잘사용하지않는다)
rpm -Uvh 패키지파일명 : 패키지 설치
rpm -e 패키지명 : 패키지 삭제


업데이트할경우 기존버전을 지우고 새버전을 설치함
(커널은 제외>원래 커널은 남겨두고 업데이트파일을 추가설치, 원래존재하던 커널 남아있음)


yum : Yellowdog Updater Modified, 인터넷을 통해 필요한파일을 
저장소(repository)에 자동으로 모두 다운로드 해서 설치하는 방식
rpm의 종속성 문제를 해결함

ls -l /etc/yum.conf/ > 기본 구성 파일 저장
ls -l /etc/yum.repos.d/ > 추가 repository 구성파일
ls -l /var/log/yum.log > 모든 설치 및 제거 트랜잭션

레포시토리
다운로드를 요청하면 해당 패키지에대한 종속성을 알려주고 종속 파일들을 설치할것인지 물음
동의하면 먼저 다운로드를 한뒤에 설치진행

yum 명령어
 yum install 패키지 = 패키지 설치
      remove 패키지 =패키지 삭제
      update 패키지 = 패키지 업데이트
        info : 패키지 정보확인
       list  : repository의 패키지 리스트 출력	

      groups list  : 그룹패키지 리스트 출력
      groups info 그룹패키지명 : 그룹패키지 정보      
      groups install 그룹패키지명 : 그룹패키지 설치
      groups remove 그룹패키지명 : 그룹패키지 삭제
      groups update 그룹패키지명 : 그룹패키지 업데이트
      
      localinstall 패키지파일명 : 패키지 파일을 yum으로 설치
      
*패키지명을 입력시에 이름에 공백(띄어쓰기)이 있는경우 "  " 로 묶어주어야 하나로 인식함
> 묶어주지않으면 각각 다른 패키지로 인식함

yum -y install 패키지명 : 패키지를 설치할때 옵션을 모두 y로 한다

provides /etc/rsyslog.conf > 해당파일이 어떤 패키지에서 파생되었는지 물어봄
(yum은 자신이 아니 외부에 패키지 정보를 물어본다(=rpm -qf ))

repository 파일설정 (확장자가 반드시 .repo이어야만 함)
파일명 . repo 로 만들고 정보는 5줄필요, 정보입력시 공백입력x
ex)
1.네트워크 레포지토리 등록
[net] > id
name=network > repo name
baseurl=http://mirror.centos.org/centos/7/os/x86_64
enabled=1     > status, 0 : disable, 1=enable
gpgcheck=0  
(유료패키지의 경우에는 gpg키(라이센스키)파일을 줌 
gpg가 있는 경우 gpgcheck=1로 설정하고 gpgkey=file:/// 를입력)

2.파일시스템 레포지토리 등록
[DVD]
name=dvd
baseurl=file:///media/cdrom >절대경로로 작성하며  cdrom의 구성이 레포지토리와 같으면가능
enabled=1     
gpgcheck=0  

네트워크보다는 파일시스템에서 받는것이 더 빠르므로( 다운로드필요x) 
가능한것은 파일시스템에서 받고 업데이트가 필요한것은 네트워크에있는 레포지토리에서 받는다




------------------------------------네트워크 관리---------------------------------------------------

네트워크 매니저 > RHEL7 부터 네트워크를 모니터링하고 관리하는 데몬
systemctl status NetworkManager

/etc/sysconfig/network-scripts > 설정파일은 여기에 저장

ifconfig/ip addr show ens33
= 윈도우의 ipconfig기능
nmtui : 네트워크 매니저를 tui (Text User Interface)로 사용
nm-connection-editor : GUI 모드로 네트워크매니저 사용

nmcli > 네트워크 매니저를 cli모드로 사용하겠다 
nmcli device : 현재 연결된 네트워크 디바이스 목록을 보여줌
nmcli device connect 장치명 : 해당장치의 네트워크 연결
nmcli device disconnect 장치명 : 해당장치의 네트워크 연결을 끊는다

nmcli connection > 현재 연결된 모든 연결을 보여줌
nmcil connection show  장치명/연결명
*ipv4.method : auto > (DHCP)

-새로운 연결만들기(DHCP)
nmcli connection add con-name dhcp ifname ens33 type ethernet autoconnect yes 
>커넥션 ID가 DHCP라는 네트워크를 ens33장치에 ethernet 형식으로 연결하겠다
오토커넥트는 yes가 기본값이므로 생략가능

*항상 설정을 바꾸고나서는 다음 명령어 사용해야 제대로 적용
nmcli connection reload 
nmcli connection up dhcp (내릴때는 down을 써주면됨> 최근에 했던 연결과 연결됨)

/etc/sysconfig/network-scripts/ 에 ifcfg-dhcp파일이 추가됨(이 파일로도 설정의 수정이가능함)

-새로운 연결만들기(static)
nmcli connection add con-name static1 ifname ens33 type ethernet ip4 "192.168.100.100/24" gw4 "192.168.100.2" 
>커넥션 ID가 static1이라는 네트워크를 ens33장치에 ethernet 형식으로 연결하고 
ip는"192.168.100.100/24" gw는 "192.168.100.2"로 설정

기존연결의 설정변경하기
nmcli connection modify dhcp connection.id static2
> dhcp라는 연결의 connection.id 를 static2로 바꾸겟다

nmcli connection modify static2 ipv4.addresses "192.168.100.200/24"
nmcli connection modify static2 ipv4.gateway  "192.168.100.2"
nmcli connection modify static2 ipv4.method manual 
>static2에 ipv4 add/gw를 추가하고 연결방식을 매뉴얼로 설정

이름을 바꾸어도 설정파일의 이름(/etc/sysconfig/network-scripts/ 에 있는 파일)은 변화x
내용에만 이름이 바뀌어있음

nmcli connection modify static2 -ipv4.addresses "192.168.100.200/24" +ipv4.add "192.168.100.201/24"
> static2에서 "192.168.100.200/24"주소를 제거하고 "192.168.100.201/24"주소를 추가함


호스트네임> [root@호스트네임 ~]
hostname > vi /etc/hostname or hostnamectl set-hostname korea
로 수정가능 , 다음 터미널부터 적용됨
or
vi /etc/sysconfig/network 

HOSTNAME=myhost 추가


nmcli con show > 연결목록 확인하기

-----------------------telnet/ssh---------------------------------------------
텔넷 접속하기
telnet 설치
yum -y install telnet*
systemctl status telnet.socket > restart/enable
firewall-config > telnet/23번포트 허용

telnet localhost로 접속가능여부 확인

텔넷 접속시 루트계정 사용방법
/etc/securetty 에 pts/1, pts/2추가 > 원격접속연결 2개 가능

텔넷 접속 확인하기
telnet localhost 

-----------------------------------------------------------------------------------------------------
오민엽강사님 myoh@nobreak.co.kr       notion(포토폴리오 만들때 유리)
-----------------------------------------------------------------------------------------------------
강의안 파일 클라우드 주소 : c11.kr/myoh-koreait03

yum install -y bash-completion.noarch
>bash 자동완성기능

#VM workstation 설정하기

1. VM workstation 설치후 key값 검색해서 라이센스 등록

2.설치후 virtual network manager에서 NAT host-only bridge네트워크 추가후 설정 
(서브넷, 게이트웨이 등등)

3.윈도우의 인터넷 설정에서 어댑터옵션> 공유에서 다른네트워크와 네트워크 공유 체크 
NAT네트워크에 해당되는  VMNET을 선택

4.어댑터옵션에서 아까 선택한 VMNET의 옵션에서 IPv4 프로토콜 설정에 들어가서
 virtual network manager에서 설정한 gateway 주소 입력

4.vm 구동후 8.8.8.8 과 host에 ping 보내보고 ifconfig로 IP확인하기


uname -a


1.server에 firewalld가 활성화되고 실행되고 있는지 확인
systemctl firewalld

2.httpd 패키지 설치
yum install -y httpd 

3. httpd.service 활성화 및 시작
systemctl start httpd.service
systemctl enable httpd.service

4./var/www/html/index.html 만들어 helloworld!입력

mkdir -p /var/www/html/
vi /var/www/html/index.html
i hello world!
esc :wq

5.webserver라는 zone을 만들고 활성화 시킨다
-ssh로 외부에서 접근가능해야함
-웹서버에 클라이언트가 접근가능해야함

firewall-cmd --permanent --new-zone=webserver
firewall-cmd --permanent --zone=webserver --add-port=22/tcp
firewall-cmd --permanent --zone-webserver --add-service=http
firewall-cmd --permanent --zone-webserver --add-service=https
firewall-cmd --reload

curl 192.168.100.150:80


GUI되도록이면 사용자제 > CLI사용하기

centos 8버전은 패키지 관리쪽에서 변경있으나 큰차이는없음

가상머신(guest OS) --SSH--- Host OS  
1.window terminal (비추)
2.VSCODE (코딩 편집기, 터미널기능) > 강의는 vscode로 사용
3.Xshell (장점 많음)

윈도우의 서브 시스템으로 ubuntu 가능해짐 > ms store에 앱이있음

매니지> 클론 : 스냅샷과 유사기능 
 
-가상머신의 네트워크 구성 (VMware 공식홈페이지에 설명있음)

1.bridge 가상의 브릿지를 만들어 가상머신과 호스트를 연결
host network AD와 연결
host PC와 guestOS (VM)이 같은 네트워크를 사용함
guest OS는 공유기에서 IP를 할당받는다.
외부와 통신가능

2.host-only : host pc에서 생성된 네트워크 카드와 연결된
guest PC들의 네트워크 생성(폐쇄망)
가상머신들끼리만 혹은 host pc와만 통신가능
(guest-guest host-guest)

3.NAT(NAPT)
host에서 IP를 할당받아 가상머신 프로그램이
자체 DHCP서버를 띄워 네트워크 대역 할당 및 통신
가상nat장비를 만듬
공인 ip >< 사설IP
1개 네트워크만 생성가능
외부와 통신가능(호스트PC를 통해서)
guest-guest /host-guest통신가능

-vscode 명령어 
ctrl + '+' '-' > 화면크기조정
ctrl + j > 터미널 내리고 올리기
ctrl + h

-ssh 계정명@ip주소
sudo yum install bash-completion > 터미널에서 자동완성기능 설치

-------------------------------------------------------------------------------------------------------------------------
프로세스 
-실행되고 있는 프로그램
스레드 : 실제 작업하는 단위

프로세서 : 프로그램을 실행하는 장치 (cpu)

systemd (system +deamon) 
-최상위 프로세스 
user level에서 실행되는 최초의 프로세스 (*kernel level > 프로그램에 의해서만 실행되는 것, 사용자가 제어할수없음)
CentOS7에서 사용
이전에는 init이라는 프로세스를 사용했음> runlevel을 사용
유닛단위로 서비스를 제어하고 관리한다.


서비스 유닛 : http ssh
소켓유닛 : 다른프로세스와 통신하는 유닛, 네트워크 소켓
마운트유닛 :  장치를 마운트 포인트에 연결하면 유닛생성
etc

/usr/lib/systemd/system  > 유닛이 저장되어있는 디렉토리


유닛 파일의 구성
[Unit] : 유닛의 일반적인 구성정보
[Service] : 실행할 프로세스의 경로
[Install] : systemctl enable과 disable에 관련된 세션

man bootup > 시스템의 부팅과정을보여주는 메뉴얼

deamon 
사용자가 직접제어하지않고, 백그라운드에서 여러작업을 수행
항상실행되는 상태로 유령처럼 떠돌아다님(좀비프로세서x)
ls , mkdir ,touch 등은 데몬이 아닌 프로그램
ppid =1 (ps --ppid 1 로 확인가능)

systemctl > 시스템 데몬을 컨트롤 하는 명령어

-유닛 파일만들기
sudo vim /usr/bin/unit_test.sh

#!/bin/bash > 이파일은 쉘스크립트 파일이다라고 선언

echo  "start unit test"

while (( 1 ))
do

    echo "this is unit test test.sh"
    sleep 2   
done

chmod +x /usr/bin/unit_test.sh


sudo vim /usr/lib/systemd/system/unit_test.service
[Unit]
Description=unit test systemd service

[Service]
type=simple
ExecStart=/bin/bash /usr/bin/unit_test.sh

[Install]
WantedBy=multi-user.target

>sudo systemctl status unit_test.service or ps -ef로 백그라운드에서 돌아가고있는지 확인하기


pstree -ap > 프로세스를 트리형태로 보여주면서 pid 붙임
(sudo yum install psmisc.x86_64  설치 필요)



ifconfig > net-tools
nslookup >sudo yum install bind-utils.x86_64 

systemctl status network.service  > 네트워크 동작확인
켜져있어야만 nmcli로 컨트롤 가능

nmcli 설정 추가
nmcli con add con-name <xxx> type ethernet ifname <xxx>
nmcli con mod conname <xxx>
1.ifname
2.ipv4.addr
3.ipv4.gateway
4.ipv4.dns
5.ipv4.method


레거시방식 : /etc/sysconfig/network-scripts내의 파일을 직접수정하는 방식을 뜻함
수정후에는 꼭 다시 연결을 up해주기 > ssh접속끊김( ip주소 바뀌었으므로 다시접속필요)

-------------------------------------------방화벽---------------------------------------------------------
서비스
동작 : systemd 제어
접근 : network 설정 , 방화벽

방화벽의 정의 : 미리 정의된 보안규칙에 기반한 들어오고 나가는 네트워크트래픽을 모니터링하고 제어하는
네트워크 보안시스템


방화벽(nat)    >web(host-only)
(host-only)    >FTP(host-only)
	     >mail(host-only)

>방화벽이 포트포워딩을 통해서 트래픽을 원하는 서비스에 보내줌

방화벽 동작
-fiwall-cmd > firewall(deamon&service) > iptables > kernel (netfilter)
firewall까지가 유저레벨에서 변경가능


방화벽 : 기본적으로 들어오는것은 차단, 나가는것은 모두 허용

방화벽이 차단할수있는것
IP/Port/Protocol/도메인주소
기본적으로는 차단이 원칙, 정책을 통해서 허용

방화벽 정책의종류
inbound > 기본설정은 모든 접속을 차단함, 자기 컴퓨터로 들어오기 시작하는 네트워크데이터를 결정(밖에서 안으로)
ex)  서버입장에서는 서버내부로 들어오는 데이터(클라이언트 > 데이터 > 서버)

outbound > 기본설정은 모든 접속을 허용, 자기 컴퓨터에서 나가는 데이터를 결정 (안에서 밖으로)
ex) 밖으로 나가는 데이터 ,  서버밖으로 (서버 > 클라이언트)
인바운드 설정을 해주면 굳이 아웃바운드설정을 해줄필요 x? (서버는 클라이언트가 요청하기전에는 아무작업도 수행하지않는다) 

서버의 경우는 연결을 확인해야하기때문에 icmp를 항상열어둔다

*참고 iptables는 centos8부터 사용x > 신경쓸필요없음

CentOS의 방화벽
firewalld.service를 통해서 방화벽을 관리함
(multi-user.target.wants에서 확인가능), Ubuntu는 ufw를 사용

firewalld-cmd(iptables)> firewalld(user level) > netfilter(kernel level)

firewalld-cmd 를 사용해서 방화벽을 관리함
장점 : runtime설정 가능 (프로그램이 돌고있는 상태에서 설정만 바꾸는것이 가능)
영구설정 가능

curl localhost >  localhost의 웹서버에 접속

curl 192.168.100.99 >  192.168.100.99의 웹서버에 접속

크롬에서 192.168.100.99로 접속 > 불가능 ( 방화벽 설정 해줘야함)
sudo firewall-cmd --add-service=http


TCP의 디멀티 플렉싱
source IP/source Port/Dest IP/Dest port 
4가지를 동시에 파악해 디멀티 플렉싱이 이루어진다.
한가지라도 다르면 다른 소켓이 형성된다.(1:1, connection-oriented)

udp (connectionless) > 포트마다 소켓을 하나만 만들어서 프로세스에 접근함  
tcp(connection-oriented) > 포트가 열리고 소스 ip/포트, dest ip/포트가 하나라도 다르면 새로운 소켓을만들어 프로세스에 접근

방화벽에서 기본으로 public존이 존재
public zone에는 기본적으로 ssh와 dhcpv6-client를 허용함
( ssh접속 불가시 이것을 확인해봐야함)

sudo firewall-cmd --add-service=http > 방화벽에서 http 서비스를 허용함
sudo firewall-cmd --add-port=400/tcp > 400번 tcp포트를 연다 (메모리에만 올라가고 재부팅되면 설정이 날아감)

sudo firewall-cmd --zone=public --list-all > 퍼블릭존의 설정을 확인
sudo firewall-cmd --permanent --add-service=http > http를 영구설정, 런타임상태는 그냥두고 설정파일만 바뀐다
sudo firewall-cmd --reload > 재부팅하지않고 영구설정을 런타임에 반영시킬수 있다
*systemctl status httpd.service 확인

방화벽의 기본구성
-기본적으로 zone이라는 단위로 정책을 묶어서 관리한다

sudo firewall-cmd --list-all-zones > 모든 존을 상세히 보기
sudo firewall-cmd --get-zones > 모든존의 이름을 보기
sudo firewall-cmd --zone=public --list-all > 해당 존의 설정을 상세히 보기
sudo firewall-cmd --get-default-zone > default zone을 확인

sudo firewall-cmd --permanent --new-zone=fwtest > fwtest라는 새로운 존을 만들기
sudo firewall-cmd --set-default-zone=fwtest > fwtest를 디폴트 존으로 설정
*디폴트존은 firewalld가 켜질때 기본으로 켜짐

-포트 포워딩

외부(공인IP) >222.22.22.2 iptime 공유기 192.168.0.1> 내컴퓨터(사설)192.168.0.10 (http서버)
       	       222.22.22.2 : 50080 >  포트포워딩 > 192.168.0.10:80

sudo firewall-cmd --permanent --zone=fwtest --add-forward-port=port=50080:proto=tcp:toport=80:toaddr=192.168.100.99
> 50080포트를 열어서 들어오는것을 80포트로 들어가게끔 만듬
크롬에서 192.168.100.99:50080 접속가능 확인

-rich rule
세부적으로 권한을 주고싶을경우 사용함
man firewalld.richlanguage에서 examples검색해서 예제 확인하기
기본틀 : sudo firewall-cmd  --permanent --add-rich-rule="rule <rule>"

sudo firewall-cmd --permanent --add-rich-rule="rule family=ipv4 source address='192.168.100.20/32' reject"
192.168.100.20/32로 들어오는 아이피는 모두 막겠다
sudo firewall-cmd --remove-rich-rule="rule family=ipv4 source address='192.168.100.20/32' reject"
rich rule 지우기


---------------------------------ssh--------------------------------------------------

open-ssh : open secure shell
보내는 패킷을 암호화 함
       client  >     네트워크   > server  
telnet 문자 >	 문자  	> 문자
ssh    문자  > 암호화 (문자)  > 복호화(암호화(문자)) =문자
*평문이 아닌 암호화돈 문자를 주고 받는다

ssh 는 데이터 전송시에는 대칭키 방식사용하고
복호화할때 비대칭키 방식사용

/etc/ssh/ssh_config : 클라이언트의 설정파일
/etc/ssh/sshd_config : 서버의 설정파일 > 허용포트

-sshd_config 의 설정값들-
*설정을 바꾼뒤에는 systemctl restart sshd 필수

hostkey > 암호화시키는 키값
#logging : 로그에대한 정보들
logingracetime 2m :  로그인시에 2분동안 접속이 불가능하면 연결 취소
permitrootlogin no : 루트사용자로 로그인이 불가능 (sudo도 사용불가능) 
> 다른사용자로 로그인한뒤 su - 로 루트로그인은 가능, se스위치로 루트로그인만 막음
PubkeyAuthentication yes : 키기반 인증 on
마지막줄에 AllowUsers/AllowGroups/DenyGroups/Denyusers 추가가능
ex)  AllowUsers user1 user

ssh user@192.168.100.99 hostname > 접속하지않고 hostname 명령어실행

#한번해보기
server(GUI) client(GUI) 실행
client > server로 접속
ssh -X centos@serverip
server> firefox www.google.com &

-타 pc에서 가상머신내의 centos접속하기
1.networkmanager>  nat setting  > portforwarding add
임의의 포트번호를 적고 머신의 IP를 적고 22번 포트를 적고 ok

2.윈도우 방화벽에  포트포워딩 시킬 포트번호를 인바운드 규칙에 추가하기

3.다른 pc에서 ssh centos@현재 pc의 ip(vm아님) -p 해당포트번호로 접속하기
ex) 윈도우 ip 10.5.6.7 
    vm NAT network 192.168.100.0
    vm ip 192.168.100.123
    포트포워딩 5000 > 192.168.100.123:22
    ssh centos@10.5.6.7 -p 5000

pc > 윈도우 방화벽 > 윈도우 : 5000 > 192.168.100.123:22 가상머신 > vm 네트워크방화벽 > 서비스

scp > secure copy
원격으로 파일을 보낼때 사용하는 명령어
scp <source file> <user-name>@<addr>:path
scp .\0303-1.txt user@192.168.100.99:/home/user

sftp > 접속해서 파일 전송
-cd/mkdir/rmdir 가능
-put > 원격 > 서버
-put
sftp user@192.168.100.99
sftp -oport=[포트번호][사용자계정@호스트주소] > 특정 포트로 접속하기
put c:\Users\KEDU506\sftptest.txt > sftp서버에 클라이언트PC의 파일을 올리기(특정파일 다운로드)

get /home/user/firea > 접속한 서버의 /home/user/firea파일을 sftp에 들어오기전 경로에 저장
get ./sftptest.txt  c:\Users\KEDU506\.vscode > 접속한 곳에서 파일을 클라이언트 PC의 특정위치에 저장

SSH 접속
공개키 방식을 사용한다.
비대칭 알고리즘 방식을 사용한다. (데이터를 암호화하고 복호화할때 사용하는 키가 다른 암호화 알고리즘을 의미)

-공개키와 개인키
공개키 > 외부에 공개된키 , 누구나 다 가지고 있을수 있음 
개인키 > 키 생성자만 갖고있는 키
*공개키로 암호화 > 개인키로 복호화 


대칭암호화 알고리즘
-비밀키 암호화 알고리즘


클라이언트>   >  서버
1. 클라이언트가 서버에게 접속요청
2. 서버가 클라이언트에게 공개키를 전송해줌
3. 클라이언트는 비밀키를 생성
4. 클라이언트는 비밀키를 서버가 보내준 공개키로 암호화
5. 클라이언트가 서버에게 암호화된 비밀키를 전송
6. 서버는 암호화된 비밀키를 받아서 서버의 개인키를 가지고 복호화 = 비밀키

cat /etc/ssh/ssh_xxxkey.pub > 공개키
클라이언트(window 홈디렉토리)의 .ssh\known_host > 공개키
서버의 공개키 저장위치
/etc/ssh/<ssh_host....>.pub


-ssh 키 기반인증의 원리
*클라이언트*는 ssh-keygen을이용하여 공개키와 개인키를 만듦
공개키의 내용은 서버에 저장하고
개인키는 클라이언트가 가지고있는다
클라이언트가 서버에 접속시에 서버가가진 공개키와 클라이언트의 개인키를 
비교하여 일치하는지 확인하는 인증방식

-키기반인증
ssh-keygen.exe > 윈도우 리눅스 둘다 있음 
ssh-copy-id 




user@192.168.100.99 
centos@192.168.100.150

1.ssh 접속 192.168.100.99 

2.ssh-keygen 
ent ent ent
192.168.100.99에 접속가능한키를 만듬

3.ssh-copy-id centos@192.168.100.150
> 만들어진 키값을 centos@192.168.100.150로 전송해줌
exit

4.
ssh centos@192.168.100.150
ssh user@192.168.100.99 
>먼저 centos로 접속 후 user에 접속
>centos 계정에서 ssh를 통해서 user에 접속하는 경우 
키값을 가지고 있으므로 비밀번호를 묻지않는다

패스워드 없이 접속가능
/etc/ssh/sshd_config
패스워드인증에 관련된 필드 > no


-윈도우(host PC)에 ssh키 옮기기 
1.두개의 리눅스준비
user@192.168.100.99 
centos@192.168.100.150

2.비밀번호없이 접속하고자 하는 계정으로 들어가서
키값을 만들고 다른 계정으로 키값을 보내줌
ssh-keygen 
ent ent ent
ssh-copy-id centos@192.168.100.150

3.윈도우에서 sftp로 centos에 접속
sftp centos@192.168.100.150
sftp> get .ssh/id_rsa c:\Users\KEDU506\.ssh
sftp> get .ssh/id_rsa.pub c:\Users\KEDU506\.ssh
복사된 키값을 host PC로 받아온다

4.ssh로 접속해서 비밀번호 없이 접속가능한지 확인
----------------------------------------------------------------
ssh root@192.168.100.100
ssh-keygen > 개인키 공개키 생성
ssh-copy-id user@192.168.100.200 > 서버에 공개키 전송
exit

ssh root@192.168.100.100 
ssh user@192.168.100.200
exit

*윈도우에서 키기반접속 적용하기
-powershell-
cd .ssh
sftp root@192.168.100.100
get /root/.ssh/id_rsa
exit

-powershell-
ssh user@192.168.100.200

*or
-powershell-
ssh-keygen
id_rsa.pub 파일의 내용을 접속하고자하는 서버의
.ssh/autorized_keys의 내용에 추가
 
-----------------------------------------------------------------------------------------------------------

c11.kr -url 단축해주는 사이트




selinux
리눅스의 보안을 강화해주는 커널
dac모델이 아닌 mac모델 사용

기존
일반 사용자 : 제한적인 권한 부여 (ACL or chmod)
시스템 사용자 : 막강한 권한 > 보안상 위험에 노출

접근제어모델
주체 : 시스템 자원에 접근 하는 사용자, 프로세스를 의미함
객체 : 파일 또는 포트와 같이 시스템 자원을 의미함
> 주체가 객체에 접근한다.

DAC모델
주체 -- 권한-- > 객체
주체가 객체에 접근할수있는지를 권한이 확인을해줌
ex) /etc/passwd rw-r--r-- 모든 시스템사용자가 읽을수있다

어플리케이션의 취약점 발생시 해당권한을 통해 접근가능


MAC모델
주체 -- 권한, 보안레이블(context), 정책허용 스위치 -- > 객체
-주체와 객체에 부여된 보안레이블과 정책허용 스위치에 의해 접근을 제어함

파일에 접근 > DAC모델 > 보안레이블 > 접근 허용
   		         보안레이블이 다르면 접근 거부 > 정책허용 스위치 사용
각 사용자와 프로세스/파일(주체 객체 가릴것 없이)에 context를 지정한다.

보안레이블(context) 
ls -Z  파일에 대한context내용을 확인가능
사용자 : 역할 : 유형 : 레벨
u       :  r     :  t    :s

ps Z -ef : 프로세스에 대한context내용을 확인가능

-curl localhost > apache(프로세스) > /var/www/index.html 을 호출

selinux가 켜진상태에서 cd /var/www/html/로 들어가기
/var/www/html/index.html를 
echo "create at /var/www/html" > index.html
echo "crate /var/" > /var/index.html  > cp /var/index.html ./
로 만들어 각각 curl 로 접근해본뒤, ls -Z 로 컨텍스트 확인(유형컨텍스트) 

*selinux가 켜져있는경우 컨텍스트가 다르면 서비스가 읽어들이지 못한다 
 selinux를 끄게되면 컨텍스트에 상관없이 읽어들임, 혹은 semanage fcontext -1

*디렉토리에 파일을 만들면 상위디렉토리의 컨텍스트를 그대로 받는다

cp -a  > 컨텍스트를 유지한채로 복사
(-a 옵션을 주지않으면 복사되는 위치의 상위디렉토리가 가진 컨텍스트로 재설정됨)

*selinux 끄고 키기
getenforce
sudo setenforce 0 > selinux를 끄기

정책허용스위치(boolean)


---------------------------------------------DHCP 서버----------------------------------------------------
systemd > 서비스설정
network, 방화벽 > 서비스 접근
Selinux > 프로세스의 접근


#서버의 구성
sever <-- client

-server 
네트워크 설정
서비스를 시작 (설정파일설정)
방화벽 open(port, protocol)

-client
접근만 가능하면 됨

DHCP 서비스
-네트워크 정보를 자동으로 할당해주고 관리해주는 프로토콜

*DHCP 가 할당해주는 것
IP/subnetmask/gateway/DNS

ip를 할당해주고 임대기간을 설정한뒤 임대기간이 지나면 반납이나 연장을 하는 방식으로 진행

DHCP동작
(client : 68/sever : 67) 
1.DHCP discover 
클라이언트가 서버에게 아이피할당을 요청 (소스아이피 x 서버주소모름)
src : 0.0.0.0 :67
dest : 255.255.255.255:68
tran ID : 888  > 자신이 요청한 것인지 아닌지를 확인하기위해 사용
로 보냄

2.Offer
서버가 클라이언트에게 ip를 사용할것인지 제안
scr : 111.111.11.11.11:67
dest : 255.255.255.255 : 68
tran ID : 888 

3.Request
클라이언트가 서버에게 정식으로 해당 IP를사용하겠다고 요청
src : 0.0.0.0 :68
dest : 255.255.255.255 : 67 > 다른 DHCP서버가있을수있으므로 브로드캐스트
tran ID : 888 

4.DHCP ACK
s > c
src :111.111.11.11 :67
dest : 111.111.11.104 :68
tran ID : 888 

*DHCP 연결이 실패하면 169.254.xxx.xxx가 할당

*DHCP서버는 스태틱으로 IP가 고정되어있는것이 기본

---------------------------------------------------------
-DHCP 실습
두개의 가상머신 준비

하나는 DHCP서버로 
하나는 DHCP client로 설정

-클라이언트 설정
새로운 네트워크연결 추가
nmcli con add con-name dhcp type ethernet ifname ens33 
nmcli con mod dhcp ipv4.method auto > ipadd 나 dns gateway를 설정하지않고 DHCP로만 받도록 설정
nmcli con up dhcp 
nmcli con reload 

혹은 기존설정의 BOOTPROTO를 DHCP로 변경
vi  /etc/sysconfig/network-scripts/ifcfg-ens33
BOOTPROTO=none > BOOTPROTO=DHCP로 변경
나머지 IPv4.addr/IPv4.dns/IPv4.gateway들은 모두 주석(앞에 # 붙이기) 처리

ifconfig로 ip가 없는지 확인 

-vmware 설정
Edit의 네트워크 매니저에서 change setting
NAT네트워크에서 User local DHCP service to distribute IP address to VMs 항목 체크해제
>VMware내의 DHCP장비의 작동을 중지시키는것


-서버 설정
dhcp 서비스를 설치하고(yum instal dhcp*)

/usr/share/doc/dhcp*/dhcpd.conf.example를 참고하여
vim /etc/dhcp/dhcpd.conf 로 작성하기

ex) subnet 192.168.100.0 netmask 255.255.255.0 {
 range 192.168.100.50 192.168.100.60;
 option domain-name-servers 8.8.8.8;
 option routers 192.168.100.2;
 option broadcast-address 192.168.100.255;
 default-lease-time 600;
 max-lease-time 7200;
}

방화벽에 dhcp를 허용하고  systemctl에서 dhcpd 를 enable start
firewall-cmd --permanent --add-service=dhcp
firewall-cmd --reload

systemctl status dhcpd
systemctl start dhcpd > 만약 설정파일이 제대로 되지않으면 오류나면서 안켜짐
systemctl enable dhcpd

tail -f /var/lib/dhcpd.dhcpd.release 로 할당이 제대로 되는지 확인하기
/var/lib/dhcpd.dhcpd.release < dhcp할당 리스트가 나오는 곳

할당된 pc에서 ifconfig로 아이피 확인

-이미 IP가할당된 뒤에, DHCP서버의 설정을 변경하는 경우 

1.서버에서 DHCP의 설정 변경후 systemctl restart dhcpd
2.클라이언트에서 ifconfig로 IP확인 > IP 변경 x (이미 할당되어서 변하지않는다)
3.클라이언트에서 systemctl restart network 
4.클라이언트에서 ifconfig로 IP확인 > IP 변경 완료

---------------------dns-------------------------------------------------------
DNS : 도메인 네임 > IP

 /etc/hosts > ip를가지고 도메인네임을 추가할수있음

webserver/dns server/client 를 만들어서 실습
vi /etc/hosts
192.168.100.150 www.nate.com
curl www.nate.comping

hosts 파일 사용시 발생하는 문제
-인터넷을 사용하는 서버가 너무많다
검색시간이 너무 오래걸린다
접속시간 너무 오래걸림

-DNS 
계층적구조를 가지고 있음

계층구분
1.root서버 > "." , 원래 모든 도메인네임에는 뒤에 .이생략되어있음 , 13개가 존재

2.top level domain server : .com .org .net .kr 

3.master name server : 
google 
└mail/search/www/drive/map
-------------------------------------
#로컬 DNS 서버
DNS 쿼리를 저장한 후에 host들이 질문하면 대신 답변해줌

1.www.naver.com > DNS
2.www.naver.com > localDNS
3.www.naver.com > root
4.www.naver.com > .com
5.www.naver.com > naver.com
6.www.naver.com > naver.com
                           └www 168.12.12.12 > client

nslookup www.naver.com 192.168.100.200
vim /etc/named.conf
cp name.empty data/xxx.zone
vi data/xxx.zone

named-checkzone > 존파일 제대로 작성했는지 체크

vim /etc/named.conf 의 존필드내용 수정
zone "xx
type master;
file data/xxx.zone

sudo named-checkconf /etc/named.conf로 오류 체크
systemctl restrat named.service

#실습2 -로컬 DNS서버 구축후 nslookup 사용하여 도메인의 IP확인
client 192.168.100.124
DNS server 192.168.100.200

ssh user@192.168.100.200
편의를 위해 su - 로 root 로 변경


yum install bind*  >dns 서버관련 패키지 설치

named.service 시작
systemctl start named.service
systemctl enable named.service

방화벽에서 dns 추가
firewall-cmd --permanent --add-service=dns
firewall-cmd --reload

cd /var/named/ > DNS zone 파일이 저장되는 디렉토리

cp named.empty data/myoh210305.co.kr.zone
>named.empty를 복사해서 /var/named/data에 새로운 존파일을 생성

vim data/myoh210305.co.kr.zone
$TTL 3H
①@       IN      ②SOA     ns.myoh210305.co.kr root.myoh210305.co.kr (
                                        0       ; serial
                                        1D      ; refresh
                                        1H      ; retry
                                        1W      ; expire
                                        3H )    ; minimum

@  ③IN      ④NS      ns.myoh210305.co.kr.  
        IN     ⑤MX 10   mail.myoh210305.co.kr. 
        IN     ⑥ A       192.168.100.150 

ns       IN    A       192.168.100.200
mail    IN    A       192.168.100.160
www   IN    A       192.168.100.150
ftp      IN   ⑦CNAME   www

* ZONE 파일에 쓰이는 레코드 설명
존파일에서의 도메인명은 항상 마침표로 끝나야한다
ex)ns.myoh210305.co.kr. / mail.myoh210305.co.kr.

①SOA >Start Of Authority의 약자 
도메인의 시작점, 도메인에 대한 선언을 하는부분
도메인의 네임서버(ns.xxx.xxx), 관리자의 메일(root.xxx.xxx) 
도메인에 대한 타이머 관련설정 가능
없으면 다른레코드는 등록할수 없음

②@> /etc/named.conf  에서 설정한 도메인 명을 불러옴
ex)
/etc/named.conf 에 다음과 같이 설정 :
---------------------------------------------
 zone "myoh210305.co.kr." IN {
        type master;
        file "data/myoh210305.co.kr.zone";
};
---------------------------------------------
zone파일에서의 @ = myoh.210305.co.kr. 로 인식

③IN >  우측의 설정을 시작

④NS > 도메인에 대한 네임서버를 지정할수 있음

⑤MX > 메일서버 지정 10,20,30과 같은 우선순위를 지정함
값이 낮을수록 우선순위 높음

⑥A > 좌측에 작성한 도메인의 IP를 지정 (IPv6 : AAAA)

⑦CNAME > 좌측에 작성한 도메인의 별칭을 지정 
ex)
@       IN      NS      ns.myoh210305.co.kr.  
ftp      IN   CNAME   www
> ftp.myoh210305.co.kr 과 www.myoh210305.co.kr의 IP 주소는 같은 값을 가진다

-그밖에 사용하는것들
TXT > 도메인에 대한 텍스트 정보를 지정
PTR > 역방향DNS에 사용되는 레코드
-------------------------------------------------------------------------------------------

named-checkzone myoh210305.co.kr myoh210305.co.kr.zone
>존파일의 유효성검사(오류체크)

vim /etc/named.conf
---------------------------------------------
zone "myoh210305.co.kr." IN {
        type master;
        file "data/myoh210305.co.kr.zone";
};
----------------------------------------------
named-checkconf /etc/named.conf
> /etc/named.conf 파일 검증(오류체크, 아무것도 출력되지않으면 오류x)

SElinux  끄기 
getenforce
setenforce 0
> 만약 selinux가 켜져있으면 컨텍스트로 인하여 named서비스가 zone파일을 불러오지 못하여
named서비스가 시작하지 못함. 그러므로 SElinux를 꺼주거나 컨텍스트를 변경하여
문제가 발생하지않도록 할것

systemctl start named.service
systemctl status named.service
>named 서비스를 재시작하고 확인하기

chown root:named /var/named/data/xxx.zone
chmod  -R 754 /var/named
>마지막으로 zone 파일의 소유그룹을 named로 바꾸고 파일의 소유그룹 권한에 읽기/쓰기를 가능하도록 바꿔준다
(소유그룹이 named로 되어있지않으면 named서비스가 zone파일을 불러오지 못하여
nslookup에서 NXDOMAIN오류가 발생할수 있음)

설정한대로 도메인의아이피가 뜨는지 확인하기
nslookup www.naver.com 192.168.100.200

--------------------------------------------------------------------------------------
NFS
리눅스 컴퓨터간에 저장공간을 공유해주는 서비스
구글드라이브나 다른 클라우드 디렉토리 서비스와 유사한 서비스를 말함
NAS와 같은 장비에서도 사용
강의에서는 NFSv4로 사용

NFS (server) /share				암호화서버
     └--- client1 /mnt/c1(mounting point)-----------┘
     └--- client2 /mnt/c2(mounting point)-----------┘
     └--- client3 /mnt/c3(mounting point)-----------┘

-서버구성
패키지 : nfs-utils
설정파일 : /etc/exports
 - 공유디렉토리 생성
 - 파일 작성 요령
 <절대경로 >     <허용IP/프리픽스>     <mount옵션>

<mount옵션> : 파일에대한 읽기/쓰기/실행 권한, 암호화방식


-클라이언트 구성
패키지 : nfs-utils 
showmount -e <서버주소>
mount -t nfs 서버주소:/디렉토리 <mounting point>

-설정
1.서버 설정
yum install -y nfs-utils rpcbind
mkdir /nfs
chmod 777 /nfs
touch /etc/exports

vim /etc/exports
------------------------------------------
/nfs	192.168.100.*(rw, sync, sec=sys)
	(or 192.168.100.0/24(rw, sync, sec=sys)) > 둘중 어떤걸써도 무방
-------------------------------------------
exportfs -v

firewall-cmd --permanent --add-service=nfs
firewall-cmd --permanent --add-service=rpc-bind
firewall-cmd --permanent --add-service=mountd
firewall-cmd --reload

systemctl start rpcbind.service
systemctl enable rpcbind.service

systemctl start nfs-server.service
systemctl enable nfs-server.service

systmectl status rpcbind
systmectl status nfs-server

*설정파일을 바꾼뒤에 시스템 재시작하지않고 exportfs -ra로 바로 적용가능

2.클라이언트 설정

yum install -y nfs-utils rpcbind

systemctl start rpcbind.service
systemctl enable rpcbind.service

showmount -e 192.168.100.200 > 서버에서 설정한 export파일의 내용이 보여짐

mkdir /mnt/nfs
mount -o rw, sync,sec=sys 192.168.100.200:/nfs /mnt/nfs

mount | grep nfs
df -Th 
로 마운트가 제대로 되었는지 확인

cd /mnt/nfs
touch filetest.192.168.100.100
루트사용자로 만들면 파일소유권한이 nfsnobody


3.서버에서 /nfs 권한 바꿔보기( 설정 변경하면 바로 적용됨)
서버
chmod 771 /nfs
chmod 773 /nfs
chmod 777 /nfs

4.


---/etc/exports 파일 형식----
/nfs	192.168.100.*(①rw, ②sync, ③sec=sys)

* 권한 
ro : 읽기전용 (default) 
rw : 읽기쓰기 클라이언트에게 읽기 및 쓰기권한 허용
no_root_squash : 클라이언트의 루트는 nfsnobody로 처리된다.

*보안 
none : 파일엑세스 익명,
sys : UID, GID값에대한 리눅스 파일권한 기준으로 파일에 엑세스한다.
kerb : 커버로스 인증서버를 사용하는 보안 옵션(별도 인증서버가 설치되어야한다)


*sec : 암호화방식 지정 none/krb5 로 변경가능

DNS서버 사용시
/nfs	*.myserver.com(rw, sync, sec=sys)

여러개의 서버 사용시
/nfs	*.myserver.com(rw, sync, sec=sys) 192.168.100.*(rw, sync, sec=sys)


마운트 
수동마운트 
클라이언트가 NFS공유 디렉토리에 접근한뒤 사용하지않아도 지속적으로 마운트가 유지

-mount 명령어를 사용해서 마운트
-fstab추가하여 마운트

*클라이언트에서 마운트 설정 변경
vi /etc/fstab
-------------------------------------------------------
192.168.100.200:/nfs /mnt/nfsshare nfs defaults 0 0
--------------------------------------------------------
mkdir /mnt/nfsshare
mount --all

자동마운트 
사용자가 접근시에는 자동으로 마운트되고 사용하지않을시에는 마운트를 해제함
자동마운트 구성에는 맵파일이 필요하다
(마스터맵, 직접맵, 간접맵)

마스터맵
└직접맵1
└직접맵2 
└간접맵1
의 형식으로 구성 
vi /etc/auto.master 
----------------------------------------------------------------
<mountingpoint>		<맵파일경로(직접or간접맵)>
----------------------------------------------------------------

직접맵 마운팅포인트가 항상존재

간접맵 마운팅포인트가 항상존재하지않고 접속시에 생성

-직접마운트 
1:1방식

-간접마운트
1:1방식 : 마운팅포인트가 존재하지않고 접속시에 마운팅포인트가 만들어짐
1:n방식


*자동마운트 직접맵 1:1방식 설정하기
-서버
mkdir -p /shares/{public,work,docs}
chmod 777 /shares/public
vi /etc/exports
-------------------------------------
/shares/public 192.168.100.0/24 (rw,sync,sec=sys)
-------------------------------------

systemctl restart rpcbind
systemctl restart nfs-server
exportfs -v


-클라이언트

yum install -y autofs
vim /etc/auto.master.d/shares.autofs > 파일명은 상관 x
--------------------------------------
/-	/etc/auto.shares
--------------------------------------

vi /etc/auto.shares
--------------------------------------------------------------
public -rw,sync,sec=sys 	192.168.100.200:/shares/public
----------------------------------------------------------------
mkdir /public
systemctl start autofs
systemctl status autofs
cd /public /
touch firea


-간접 1:1 마운트 실습(설정파일만 변경해주면됨)
-서버
vim /etc/export
-----------------------------------------------------
/shares/public 192.168.100.0/24 (rw,sync,sec=sys)
/shares/work 192.168.100.0/24 (rw,sync,sec=sys)
/shares/docs 192.168.100.0/24 (rw,sync,sec=sys)
------------------------------------------------------
systemctl restart rpcbind
systemctl restart nfs-server
exportfs -v

-클라이언트
umount 192.168.100.200:/shares/public
sudo mkdir /tets
vi /etc/auto.master.d/share.autofs
--------------------------------------
/test	/etc/auto.shares
--------------------------------------

vi /etc/auto.shares
--------------------------------------------------------------
public -rw,sync,sec=sys 	192.168.100.200:/shares/public
work -rw,sync,sec=sys 	192.168.100.200:/shares/work
docs -rw,sync,sec=sys 	192.168.100.200:/shares/docs
----------------------------------------------------------------
> 경로앞에 루트를 붙이지 않아야함

systemctl start autofs.service

cd /test
cd work 로 접속가능한지 확인하고

서버에서 디렉토리 권한 수정후 파일 생성 가능여부 확인

*간접마운트 1:n 방식 실습
-서버는  간접마운트 1:1과 설정동일

-클라이언트 설정
/etc/auto.master.d/share.autofs 는 그대로

vi /etc/auto.shares
--------------------------------------------------------------
* -rw ,sync,sec=sys 	192.168.100.200:/shares/&
----------------------------------------------------------------
systemctl restart autofs



----------------------------------------------------------------

*SMB(samba) 스토리지

LAN에서만 사용가능, 계정으로 인증하는 시스템
CIFS : 확장된 공간에서 사용가능

SMBD (SMB Deamon) 
-윈도우 클라이언트에게 파일과 프린트서비스를 제공
-SMB프로토콜을 이용해 사용자인증 , 리소스 잠금, 자료공유 가능

windbindd 
-윈도우 계열 서버로부터 사용자와 그룹정보를 리눅스/유닉스 시스템이
이해할수 있도록 해줌

windows < --SMB-- > windows
      |		         |
    SMB		       SMB
      |		         |
    Linux	<-- NFS -->   Linux

*윈도우에서 서비스를 켜주면 SMB와 NFS 둘다가능함


*SMB스토리지 구성 실습*
-서버에 패키지 설치 및 디렉토리 구성
yum install -y samba samba-client

sudo mkdir -p /samba/smb1 
chmod -R 777 /samba/
chown -R smb1:smb1 /samba
setenforce 0

-smb 계정생성
useradd -s /sbin/nologin smb1 > 로그인하지않는 사용자를 추가
su smb1 > 로그인불가능

-smb 사용자 등록
smbpasswd -a smb1 >-a : 추가 -x :제거
pdbedit -L > smb사용자의 리스트 확인

vim /etc/samba/smb.conf 아래에 다음과 같은 설정을 추가
---------------------------------------------
[first]
	path = /samba/smb1
	browseable = no
	write list = smb1
	valid users = smb1
	hosts allow = 192.168.100.0/24
----------------------------------------------


systemctl start smb nmb

firewall-cmd --permanent --add-service=samba
firewall-cmd --reload

----클라이언트

yum install -y cifs-utils
setenforce 0

-마운팅포인트 
mkdir -p /mnt/smb1

vim /root/cred
-------------------------------
username=smb1
password=smb1
-------------------------------
chmod 400 /root/cred
> 보안을 위해서 smb사용자 리스트를 root홈 디렉토리에 보관하고 사용자만 읽을수 있도록 설정

-마운트 시키기
1.mount -o username=smb1 //192.168.100.200/first /mnt/smb1
> 비밀번호 입력후 접속

2.mount -o credentials=/root/cred //192.168.100.200/first /mnt/smb1
> /root/cred 파일에있는 사용자 목록을 참고하여 로그인

3.vi /etc/fstab
//192.168.100.200/first 	/mnt/smb1	 cifs	 credentials=/root/cred

sudo umount //192.168.100.200/first

윈도우 실행창 \\192.168.100.200 
로그인해서 확인하기
-------------------------------------------------------------------------------------------------

---------------------------HTTP----------------------------------------------------------------

*HTTP  : hyper text transfer protocol
-html을 전송하기위한 프로토콜
-웹브라우저에서 주소를 입력하면 기본으로 80번/tcp(443) 포트로 접속
-만약 http서비스를 다른포트로 열었다면 주소뒤에 :포트번호로 명시해주어야함
-HTTP 요청 > HTTP로 응답
-정적컨텐츠만 전송할수 있다.
-동적컨텐츠들은 사용자의 요청에 따라 다른결과를 가져옴, 서버사이트 스크립트라고도 한다
ex) jsp php asp 같은 확장자들

-apache 웹서버 > php 와 mariaDB를 사용한다(python도 사용가능)


주요 디렉토리
- /var/www/ : 웹페이지 컨텐츠의 기본디렉토리
- /etc/httpd/conf/: 서버의 주 설정파일 저장
- /etc/httpd/conf.d/ : 추가설정관련 파일 저장
-/usr/share/doc/httpd : 웹서버 관련 문서 파일


-기본 http 실습

yum install -y httpd
systemctl enable httpd.service
systemctl start httpd.service
firewall-cmd --permanent --add-service=http
firewall-cmd --reload
touch /var/www/html/index.html
vi /var/www/html/index.html
-----------------------------------------
hello /var/www/html/indext.html
----------------------------------------
curl localhost


selinux 끄기

mkdir /home/user/www
echo " hello world /home/user/www " > /home/user/www/index.html
curl 192.168.100.200

vim /etc/httpd/conf/httpd.conf
-------------------------------------------------
documentRoot /home/user/www/

#추가
<Directory "/home/user/www">
	Options indexes FollowSymLinks
	AllowOverride None
	Require all granted
</Directory>
-------------------------------------------------
sudo ls -ald /home/user
sudo chmod 705 /home/user/
curl 192.168.100.200

ps -ef | grep httpd


-가상호스트(virtual host) 구성

구성에 따라서 apache 웹서버가 여러 웹사이트를 서비스하도록 구성할수 있다.
3가지로 나뉨
1.이름기반 가상호스트 : 웹사이트의 이름을 사용하여 구분
2. IP 기반 가상호스트 : IP 주소를 사용하여 구분
3. 포트 기반 가상호스트 : 접근하는 포트를 통해 구분

-이름기반 가상호스트 실습

first.myoh.com
second.myoh.com

*방법1 : /etc/resolv.conf를 수정
-서버
192.168.100.200 first.ciw0707.com
192.168.100.200 second.ciw0707.com

vim /etc/httpd/conf.d/virutalhost.conf
--------------------------------------------
<VirtualHost 192.168.100.200:80>
DocumentRoot " /var/www/html"
ServerName "first.ciw0707.com"
</VirtualHost>

<VirtualHost 192.168.100.200:80>
DocumentRoot " /var/www/html2"
ServerName "second.ciw0707.com"
</VirtualHost>
---------------------------------------

mkdir /var/www/html2
cd html2/
echo "world" > index.tml
systemctl restart httpd.service

-클라이언트 
vi /etc/hosts
----------------------------------------
192.168.100.200 first.ciw0707.com
192.168.100.200 second.ciw0707.com 
----------------------------------------
curl first.ciw0707.com
curl second.ciw0707.com 

*방법2 : dns 서버 구성
ns .ciw0707.com

www IN A 192.168.100.200
first IN CNAME www
second IN CNAME www

-서버
yum install bind*

cp /var/named/named.empty /var/named/data/ciw0707.zone
vi /var/named/data/ciw0707.zone
-----------------------------------------------------------------
$TTL 3H
@       IN SOA  ns.ciw0707.com root.ciw0707.com (
                                        0       ; serial
                                        1D      ; refresh
                                        1H      ; retry
                                        1W      ; expire
                                        3H )    ; minimum

@       IN      NS      ns.ciw0707.com.
ns      IN      A       192.168.100.200
www     IN      A       192.168.100.200
first   IN      CNAME   www
second  IN      CNAME   www
------------------------------------------------------------------

vi /etc/named.conf
----------------------------------------------------------------
options {
        listen-on port 53 { any; };
        listen-on-v6 port 53 { none; };
        directory       "/var/named";
        dump-file       "/var/named/data/cache_dump.db";
        statistics-file "/var/named/data/named_stats.txt";
        memstatistics-file "/var/named/data/named_mem_stats.txt";
        recursing-file  "/var/named/data/named.recursing";
        secroots-file   "/var/named/data/named.secroots";
        allow-query     { any; };

#추가
 zone "ciw0707.com." IN {
        type master;
        file "data/ciw0707.com.zone";
};

------------------------------------------------------------------------
named-checkzone ciw0707.com.zone /var/named/data/ciw0707.com.zone
named-checkconf /etc/named.conf

firewall-cmd --permanent --add-service=dns
firewall-cmd --reload

systemctl restart named

-클라이언트 설정
yum install bind*
nslookup www.ciw0707.com
nmcli con mod ens33 ipv4.dns 192.168.100.200
nmcli con up ens33
nmcli con reload

curl first.ciw0707.com
curl second.ciw0707.com
curl www.ciw0707.com

---------------------------------------------------
ip기반 가상호스트
- vmware 에서 network card 를 1개 더 추가한후 ip를 부여한다.

# /etc/httpd/conf.d/virtualhost.conf
	<VirtualHost 192.168.100.20>
	        DocumentRoot    "/var/www/html"
	        ServerName      "first.myoh210309.co.kr"
	</VirtualHost>
	
	<VirtualHost 192.168.100.146>
	        DocumentRoot    "/var/www/html2"
	        ServerName      "second.myoh210309.co.kr"
	</VirtualHost>



- 포트기반 가상호스트
# /etc/httpd/conf.d/virtualhost.conf
	<VirtualHost 192.168.100.20:80>
	        DocumentRoot    "/var/www/html"
	        ServerName      "first.myoh210309.co.kr"
	</VirtualHost>
	
	<VirtualHost 192.168.100.20:8080>
	        DocumentRoot    "/var/www/html2"
	        ServerName      "second.myoh210309.co.kr"
	</VirtualHost>


# /etc/httpd/conf/httpd.conf
			Listen 80
			Listen 8080
- 방화벽 추가 설정후 서비스 재시작
firewall-cmd --permanent --add-port=8080/tcp


<설정 완료후 존파일/virtualhost.conf>
cat /etc/httpd/conf.d/virtualhost.conf
----------------------------------------------------
<VirtualHost 192.168.100.200:80>
DocumentRoot " /var/www/html"
ServerName "first.ciw0707.com"
</VirtualHost>

<VirtualHost 192.168.100.200:80>
DocumentRoot " /var/www/html2"
ServerName "second.ciw0707.com"
</VirtualHost>

<VirtualHost 192.168.100.150:80>
DocumentRoot " /var/www/html3"
ServerName "www.ciw0707.com"
</VirtualHost>

<VirtualHost 192.168.100.200:8080>
DocumentRoot " /var/www/html3"
ServerName "second.ciw0707.com"
-----------------------------------------------------------

cat /var/named/data/ciw0707.com.zone
-----------------------------------------------------------------
$TTL 3H
@       IN SOA  ns.ciw0707.com root.ciw0707.com (
                                        0       ; serial
                                        1D      ; refresh
                                        1H      ; retry
                                        1W      ; expire
                                        3H )    ; minimum

@       IN      NS      ns.ciw0707.com.
ns      IN      A       192.168.100.200
www     IN      A       192.168.100.150
first   IN      A	192.168.100.200
second  IN      CNAME   first
------------------------------------------------------------------

vi /etc/named.conf
-------------------------------------------------------------------------
options {
        listen-on port 53 { any; };
        listen-on-v6 port 53 { none; };
        directory       "/var/named";
        dump-file       "/var/named/data/cache_dump.db";
        statistics-file "/var/named/data/named_stats.txt";
        memstatistics-file "/var/named/data/named_mem_stats.txt";
        recursing-file  "/var/named/data/named.recursing";
        secroots-file   "/var/named/data/named.secroots";
        allow-query     { any; };

#추가
 zone "ciw0707.com." IN {
        type master;
        file "data/ciw0707.com.zone";
};
---------------------------------------------------------------------------


</VirtualHost>
<클라이언트에서 확인용 쉘스크립트만들기>
vi curltest.sh
--------------------------------------------------------------
echo -e "\E[0;34m <curl www.ciw0707.com> \E[0m"
curl www.ciw0707.com
echo -e "\E[0;31m <curl first.ciw0707.com> \E[0m"
curl first.ciw0707.com
echo -e "\E[0;33m <curl second.ciw0707.com> \E[0m"
curl second.ciw0707.com
echo -e "\E[1;33m <curl second.ciw0707.com:8080> \E[0m"
curl second.ciw0707.com:8080
------------------------------------------------------------------
[user@client ~]$ /home/user/curltest.sh 
 <curl www.ciw0707.com>
hello world
www.ciw0707.com
html file
/var/www/html3/index.html
 <curl first.ciw0707.com>
hello world
first.ciw0707.com
htmlfile
/var/www/html/index.html
~
 <curl second.ciw0707.com>
hello world
second.ciw0707.com
htmlfile
/var/www/html/index.html
 <curl second.ciw0707.com:8080>
hello world
www.ciw0707.com
html file

-----------------------------------------http/https---------------------------------------------------

-http구성
app
-----
tcp
-----
ip

-https의 구성
app
----ssl socket
SSL
----tcp socket
tcp
---------
IP

*SSL 
통신내용을 암호화해서 공격자에게 노출되는 것을 막을수 있다 (기밀성)
인증서를 통해 클라이언트가 접속하는서버가 신뢰할수있는 있는 서버인지를 판단할수 있다.(무결성,인증)


-https 통신방법
1. (c->s)client Hello : 사용할 암호화 방식을 전송

2. (c<-s)server Hello : 클라이언트가 통보한 암호화 방식중에 자신이 사용할 암호화 방식을 선택하여
클라이언트에게 전달, 공개키와 인증서도 함께 전달

3. (c--s)인증서 확인 : 클라이언트는 서버가 전달한 인증서가 CA에 의해 발급된 인증서인지 브라우저에 
내장된 CA의 리스트와 비교하여 확인한다

4. (c->s) 대칭키 요청 전송 : 서버의 공개키를 사용하여 대칭키를 암호화하여 전송한다.

5. (c<-s) 컨텐츠 전송 : 클라이언트에게 받은 대칭키를 이용하여 컨텐츠를 전송한다.

6. (c--s) 컨텐츠 표시 : 서버로부터 전송받은 데이터를 복호화하여 웹브라우저에 표시한다.


-https 실습

<서버>
http 설치후실행
index.html만들고
방화벽에 http,https허용

yum install openssl

CA인증서 생성 서버의 개인키 생성(서버 자신이 인증기관)
openssl genrsa -out private.key 2048
openssl req -new -key private.key -out cert.csr(설정확인창은 모두엔터)

openssl x509 -req -signkey private.key -in cert.csr -out cert.crt
(x509표준을 따르는 인증서)

ls -l cert.csr
mv cert.crt /etc/pki/tls/certs/
mv private.key /etc/pki/tls/private
restorecon -Rv /etc/pki/tls/ (or setenforce 0)
chmod 600 /etc/pki/tls/private/private.key

yum install mod_ssl

vim /etc/httpd/conf.d/ssl.conf
-----------------------------------------------------------
SSLCertificateFile /etc/pki/tls/certs/cert.crt

SSLCertificatekeyFile /etc/pki/tls/private/private.key 

-------------------------------------------------------------
systemctl restart httpd

웹브라우저에서
https://192.168.100.200


-----------------------word presss------------------------------

*아파치 -------php -------Mysql

LAMP 구성 > workpress
LAMP : L(Linux) A(apache) M(mariaDB or Mysql) P (php)

##아파치와 PHP연동##

php용 repository : http://rpms.remirepo.net/enterprise/remi-release-7.rpm

<서버구성>
yum install -y http://rpms.remirepo.net/enterprise/remi-release-7.rpm

yum install  -y --enablerepo=remi-php72 install php
yum install  -y --enablerepo=remi-php72 install php-mysql

yum install php72 php72-php-fpm php72-php-mysqlnd php72-php-opcache php72-php-xml php72-php-xmlrpc php72-php-gd php72-php-mbstring php72-php-json
yum install yum-utils-noarch
yum install php72
vim /var/www/html/info.php
-------------------------------------------------------
<?php
phpinfo();
?>
--------------------------------------------------------
vi /etc/httpd/conf/httpd.conf
------------------------------------------------------
AddType application/x-httpd-php .html .htm .php .inc
AddType application/x-httpd-php-source .phps

-------------------------------------------------------

php.ini 에서 short_open_tag = On


systemctl restart httpd

웹브라우저에서
192.168.100.200/info.php
안되면 php -v로 php 정상설치 확인


##phpmyadmin 설치##
*아파치 ---- 장고 --- maria DB

yum install mariadb-server mariadb

systemctl start mariadb.service

mysql_secure_installation
yyyyy

yum install --enablerepo=remi-php72 phpmyadmin

vim /etc/httpd/conf.d/phpMyAdmin.conf
--------------------------------------------
Require ip 127.0.0.1 192.168.100.0/24
----------------------------------------

systemctl restart httpd

웹브라우저에서 
192.168.100.200/phpmyadmin

root로 로그인



###word press 설치###

mysql -u root -p 
> 패스워드입력하면 mariaDB접속

CREATE DATABASE wordpress CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;
GRANT ALL ON wordpress.* TO 'wordpressuser'@'localhost' IDENTIFIED BY '1q2w3e4r';
exit

yum install wget

wget https://wordpress.org/latest.tar.gz
 tar -zxvf latest.tar.gz -C /var/www/html/
chown -R apache:apache /var/www/html/wordpress/

vim /etc/httpd/conf.d/wordpress.conf 
-------------------------------------------------------
<VirtualHost *:80>
        DocumentRoot /var/www/html/wordpress
</VirtualHost>
------------------------------------------------------- 
systemctl restart httpd

웹브라우저에서 
192.168.100.200/phpmyadmin
ID :wordpressuser ps : 1q2w3e4r 로 로그인


http://192.168.100.200/wp-admin/

vi /var/www/html/wp-config.php 만들고 다음 내용 붙여넣기
--------------------------------------------------
<?php
/**
 * The base configuration for WordPress
 *
 * The wp-config.php creation script uses this file during the
 * installation. You don't have to use the web site, you can
 * copy this file to "wp-config.php" and fill in the values.
 *
 * This file contains the following configurations:
 *
 * * MySQL settings
 * * Secret keys
 * * Database table prefix
 * * ABSPATH
 *
 * @link https://wordpress.org/support/article/editing-wp-config-php/
 *
 * @package WordPress
 */

// ** MySQL settings - You can get this info from your web host ** //
/** The name of the database for WordPress */
define( 'DB_NAME', 'wordpress' );

/** MySQL database username */
define( 'DB_USER', 'wordpressuser' );

/** MySQL database password */
define( 'DB_PASSWORD', '1q2w3e4r' );

/** MySQL hostname */
define( 'DB_HOST', 'localhost' );

/** Database Charset to use in creating database tables. */
define( 'DB_CHARSET', 'utf8mb4' );

/** The Database Collate type. Don't change this if in doubt. */
define( 'DB_COLLATE', '' );

/**#@+
 * Authentication Unique Keys and Salts.
 *
 * Change these to different unique phrases!
 * You can generate these using the {@link https://api.wordpress.org/secret-key/1.1/salt/ WordPress.org secret-key service}
 * You can change these at any point in time to invalidate all existing cookies. This will force all users to have to log in again.
 *
 * @since 2.6.0
 */
define( 'AUTH_KEY',         'mTLZA(%9<oJX{mb5`qPStYs:R)56.vyqZ00~BT:v}?)Z]hO`L[_8^XHSVrplX8Z5' );
define( 'SECURE_AUTH_KEY',  '21s@O^vTg;wFgCh]dOKuC>+5RcTID96T|~nHyFFwsK>X#bghJlN=rr4{y&K[j5/^' );
define( 'LOGGED_IN_KEY',    'MjN%sG?kHKeh#![gtH,v~HvqG R{qzQ~oU`[c8c/PC/QlfOeq?s> k1BMEX~A|Dp' );
define( 'NONCE_KEY',        'c;=-mSh+3mGF:=_{bjk~w Cm t-p*auRvh=7.uCS=uv}, 0_e!!Wj V)g}d4;ROX' );
define( 'AUTH_SALT',        'M&Uam7I)fF*QdlqSQVAV4jW( $<589Dx8]cwKcI$n?^XJCk9=<=uwjdt ?,##~jP' );
define( 'SECURE_AUTH_SALT', 'SPA1Dx#*X~,H0X&d}Gi<V#IB&Ibb){82Vaig7j#}rdec|*6,G5fhhn*!QMhTbrlq' );
define( 'LOGGED_IN_SALT',   'P1wwq7!:#As}Kqi)xPieJrCx@Q-ivM$rS:%~sygiJMsb/Y9eD6JjUqdXMr:h(3Hb' );
define( 'NONCE_SALT',       '^zF-U-v)<T]>!!N!hN@$fg)u?T)==Er2B5[Hc+6CRb=44Br=n$k+1q2F7ZdhZhz`' );

/**#@-*/

/**
 * WordPress Database Table prefix.
 *
 * You can have multiple installations in one database if you give each
 * a unique prefix. Only numbers, letters, and underscores please!
 */
$table_prefix = 'wp_';

/**
 * For developers: WordPress debugging mode.
 *
 * Change this to true to enable the display of notices during development.
 * It is strongly recommended that plugin and theme developers use WP_DEBUG
 * in their development environments.
 *
 * For information on other constants that can be used for debugging,
 * visit the documentation.
 *
 * @link https://wordpress.org/support/article/debugging-in-wordpress/
 */
define( 'WP_DEBUG', false );

/* That's all, stop editing! Happy publishing. */

/** Absolute path to the WordPress directory. */
if ( ! defined( 'ABSPATH' ) ) {
	define( 'ABSPATH', __DIR__ . '/' );
}

/** Sets up WordPress vars and included files. */
require_once ABSPATH . 'wp-settings.php';
------------------------------------------------------------------------------


편집한뒤에 192.168.100.200으로 접속해서 
제대로 적용되었는지 확인하기


selinux 영구설정
vim /etc/selinux/config
--------------------------------------------------
SELINUX=permissive
--------------------------------------------------

-파일 내용 검색해서 바꾸기-

cat tests

a/s/d/f
a/s/d/f 1
a/s/d/f=2
a/s/d/f/3

sed -i "s/a\/s\/d\/f 1/change/g" tests

cat tests
a/s/d/f
change
a/s/d/f=2
a/s/d/f/3

---------------------------------쉘스크립트---------------------------------------------------

커널과 쉘

커널 : 하드웨어와 인터페이스를 연결하는부분
리눅스 /유닉스 시스템이 부팅될때 가장먼저 읽혀지는 운영체제의 핵심부분
- -프로세스 스케쥴링, 메모리관리, i/o 장치관리, 파일관리

쉘 : 운영체제의 가장 바깥에 위치함 
사용자가 명령어를 입력 > 해석 > 사용자가 지정한 명령어를 프로그램을 실행하는 인터페이스
ex) bahs ksh csh zsh(ohmyzsh)

-쉘 변경하기
echo $SHELL
/bin/bash
sudo yum install git zsh
sh -c "$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)"
zsh 입력
sudo chsh -s /bin/zsh
*터미널글꼴을 변경하면 폰트가 깨지지 않는다

Shell script
작업들을 자동화 하기위한 shell command의 집합
특징 : 쉽고 빠르다
자동화 > 쉘스크립트 > ansible 

#권한을 바꿔서 실행하는 기능(root 또는 다른사용자의 권한으로 실행
su user   -c :  user의 권한으로 쉘을 실행한다
쉘스크립트는 실행권한이 있어야만 실행가능

#쉘스크립트 실행
/home/user/shell/day1/test.sh
현위치 : /home/user/shell/day1/
절대경로로 실행 : /home/user/shell/day1/test.sh
상대경로로 실행 : ./test.sh

BASH 
-A&T 벨연구소의 스티븐본이 만든 본쉘을 기반으로 만든 쉘
시작파일
-shell이 처음 시작할때 shell을 초기화 하기위한 시작파일(.bashrc )을 실행한다.

/etc/profile > /etc/profile.d/
/etc/bashrc > 각 계정 홈의  /.bashrc 

-bash 쉘이 실행되는 단계
~/.bash_profile > ~/.bashrc > /etc/bashrc 순서로 실행된다 

##로그인 쉘과 비로그인 대화형쉘, 비대화형 쉘##

login shell : 
/etc/profile ---> /etc/profile.d/
/etc/bashrc ---> 각 계정 홈의  /.bashrc 

/etc/profile : 처음 bash에 실행하는 사용자들을 위한 기본설정을 저장해두는곳
/etc/profile.d/ : /etc/profile을 통해서 실행되는  .sh 확장자를 가진 파일들을 보관해두는곳

-대화형 비로그인쉘
로그인 하지않는 쉘
logout 명령이 아닌 exit로  쉘을 종료
GUI에서 터미널을 띄우면 수행되는 쉘이 비로그인 쉘 (로그아웃으로 종료가 불가능)

shell scrip
t#! /bin/bash
shell script의 선언부
생략가능하지만 생략하면 오류발생할수잉ㅆ음
#! (hash-bang,shebang) :shell이 무엇인지 kernel에 전달

변수
문자,숫자,밑줄로 구성된 이름을 가진 인자를 변수라고한다.
변수는 숫자가아닌 문자나 밑줄로 시작해야한다.
ex) 333hi (x)
사용자 변수 : 사용자이름을 정하거나 값을 할당한 변수들을 의미한다.

쉘변수와 환경변수
기본적으로 변수는 만들어진 shell안에서만 사용가능하다(지역변수) 이를 shell 변수라고 한다
set /unset 명령어를 통해서 지역변수를 확인할수 있다.
localval=lv1
$localval
echo $localval
변수는 메모리에만 잠깐올라갔다가 쉘을 다시 실행하면 
.bashrc에 지정하면 쉘을  시작할때 마다 변수가 지정됨
ex)
vi .bashrc
-------------------------
localval=lv1
localval2=ls
-------------------------
bash
set | grep localval

alias : $를 쓰지않아도 변수를 사용가능(하나의 명령어로 만들어버림)

unset  localval


export 
프로그램 실행 shell >shell만들어진 셜로부터 파생된 셀 안에서 변수를 사용하기위해서는 export를 해줘야한다
(전역변수) 이런종류의 변수를 환경변수라한다
env printenv등의 명령어로 환경변수를 호출할수있음

localval=lv1
export | grep lv1
export | grep localval

export localval
export | grep lv1
export | grep localval
> declare -x localval="lv1"

declare : 변수를 선언하고 변수의 속성을 설정해주는 명령어
속성 : 배열(a) 함수이름(f) 정수형(i) 읽기전용(r) 환경변수(x)

변수의 타입지정
bash 변수는 타입을 구분하지않고 기본적으로는 문자열, 문맥에 따라서 연산처리한다.
declare -r str_val
readonly
declare -r

declare -i num_val=10
num_val2=10
set | grep num_val
declare -i

declare -a arr_val
arr_val1=()
declare -a

변수 할당
변수명=value (띄어쓰기 x)



#! /bin/bash
echo " 비밀번호입력"
read pswd
if [ $pswd != 111 ]
then
exit 0
fi

echo " 수정전"

read word
echo "수정후"
read word1

echo "입력 : $word"
echo "입력 :$word1"
sed -i 's/'$word'/'$word1'/g' /home/user/aa

PS1 = '

shell-script arg1 arg2 arg3 ...
        $0      $1      $2     $3
${10} : 10번째 인자부터는 중괄호로 묶어서 사용


set명령어를 옵션없이 사용하면 위치 parameter를 setting 한다
ex) 
set aaa bbb ccc ddd eee fff
echo $1
echo $2
echo $# 위치파라미터 개수
echo $@ 위치파라미터를 모두 보여줌



vi aa3.sh
#! /bin/bash
echo 'positional parameter'
echo "P1: "${0}
echo "P2: "${1}
echo "P3: "${2}
echo "P4: "${3}
echo "P5: "${4}
echo "P*: "$* : 스크립트에 전달된 인자들을 모아놓은 문자열. 하나의 변수에 저장되며 IFS 환경변수의 첫번째 문자로 구분된다.
echo "P@: "$@ $*과 같다. 다만 구분자가 IFS변수의 영향을 받지 않는다
echo "P!: "$!  마지막으로 백그라운드에서 실행된 명령어의 PID 값을 출력한다.
echo "P#: "$# 스크립트에 넘겨진 인자의 갯수
echo "P$: "$$ 현재 쉘의 PID값을 출력한다.
./aa3.sh hellow myoh world 

키워드 변수
상속받거나 선언된 변수들
일반적으로 export된 환경변수

HOME 
홈계정이 만들어질때 사용
로그인쉘인 홈디렉토리명을 상속받아서 환경변수(HOME)에 할당

PATH
프로그램을 실행하기 위해 사용되는 환경변수

S1
- 사용자 프롬프트
- PS1 심볼에 따라서 변경된다. 
\$, \H, \@, \u, \T, 
$(command)

man bash 참고하기

/.bash_history : history 저장파일
/.bahs_logout : 로그아웃시에 실행할 스크립트쉘

----------------------------------------------------------------------------------------------------------

입출력
-입력 : 키보드/장치/파일로 입력 

출력 : 모니터 /파일로 출력

xxxx(input) >shell script > yyyy(out put)
표준파일 디스크립터
-리눅스는 모든 개체를 파일로 다룬다.
-파일 디스크립터 : 파일을 식별하는 음이아는 고유 정수
        -프로세스 한개당 최대 9개의 디스크립터를 열수있음
        -bash 쉘은 특별한 목적으로 0,1,2 예약
        0 STDIN : 표준 입력 
        1 STDOUT : 표준출력
        2 STDERR : 표준에러 

text terminal
keyboard --stdin(0)--> program -- stdout(1) -->display
                                               └----- STDERR(2) -----┘

표준입력 
-프로그램이 정보를 얻는곳
-기본적으로 쉘은 키보드로부터 표준입력을 받는다
리다이렉트 기호 (< ,>)  리눇의 표준 입력 파일 디스크립터를 가리키는 방향이 바뀜
기본방향은 키보드와 디스플레이
ex) cat <aa3.sh 
(cat은 입력을 받아 출력해주는 프로그램 
aa3.sh파일을 입력받아 출력)

표준출력(1>)
프로그램의 실행된 결과를 보내는곳
ex)ls -al >stdo1 or ls -al 1>stdo1
display로 가야할 모든 출력대신 쉘이 지정한 파일로 리다이렉트된다.

표준 에러 (2>)
프로그램의 실행중 발생한 에러
echo "error message">&2  에러메세지 발생시키기
-----------------------------------------------------------------------------------------------------------------
#! /bin/bash
exec 1>testout 2>testerr
for i in {1..10..1}
do

        echo " this is test ${i}"
done
echo "this is error" >&2

exec 명령은 새로운 쉘을 시작 STDOUT 파일 디스크립터를 파일로 리다이렉트해줌
스크립트에서 STDOUT으로 가는 모든 출력은 파일로 리다이렉트

shell script실행 > exec 실행  >new shell 실행 >출력

#! /bin/bash
exec 0< testfile
count=1
while read line
do
        echo "line #$count : $line "
        count=$(( $count+1 ))

done

사용자 정의 리다이렉트 
3~8까지의 숫자는 별도로 지정가능함


#! /bin/bash
echo " this is desc1"
echo " this is desc2" >&2
echo " this is desc3" >&3

this is desc1
 this is desc2
userdesc1.sh: line 4: 3: Bad file descriptor

sh userdesc1.sh 1> desc1
sh userdesc1.sh 2> desc2
sh userdesc1.sh 3> desc3

디버깅 bash -x를 사용하여 디버깅가능
PS4 프롬포트를 사용하여 가능

조건문 (IF)
if 만약 ~하면 ~하겠다
else 그렇지않으면 ~하겠다

기본구조
if test-command
        then
        comands
        else
        comands
fi
조건이 TRUE면 then 이하의 커맨드실행
조건이 FALSE면 else  이하의 커맨드 실행

if [ $word1 = $word2]    =    if test $word1 = $word2

조건문의 true/false여부 :  echo$?를 이용해서 확인가능 (true = 0 False =1)
ex)
test $word1 = $word2
 echo $?
 1

man test을 통해서  if의 옵션을 확인할수 있다

일반 쉘에서도 사용가능 if [ -f /etc/rc.local ]; then echo :file exist; fi

if systemctl status httpd | grep -w "inactive" ; then echo ' restart httpd! '; systemctl restart httpd; systemctl status httpd | grep -w active; fi

if 형식 
세미콜론 이용
대괄호 이용
if test command 이용


elif : elseif
조건문을 여러가지 사용해야할때 사용

if test-comand 
        then 
                commands
        elif test-comand2
                then 
                        commands
        elif test -command3
                then
                        command2
        else

fi

두개이상의 변수를 expression 에 넣는경우 이런식으로 사용해야함
if [ $word1 = $word2 ] && [ $word2 = $word3 ] 
or
if [ $word1 = $word2 -a $word2 = $word3 ]

--------------------------------------------------------------------
#! /bin/bash

read -p "word1 ? : " word1
read -p "word2 ? : " word2
read -p "word3 ? : " word3

if [ $word1 = $word2 ] && [ $word2 = $word3 ]
then
echo "1,2,3"

elif [ $word1 = $word2 ]
then
echo '1,2'

elif [ $word2 = $word3 ]
 then
echo '2,3'

elif [ $word1 = $word3 ]
 then
echo '1,3'

else
echo "allno"
fi
#순서 중요!
----------------------------------------------------------------
if [ $word1 = $word2 ] && [ $word2 = $word3 ] = if [ $word1 = $word2 -a $word2 = $word3 ]
if [ $word1 = $word2 ] || [ $word2 = $word3 ] = if [ $word1 = $word2 -o $word2 = $word3 ]
if [ $word1 = $word2 ]  [ $word2 = $word3 ]

/home/user/test > /home/user/test.break
-파일 점검 스크립트를 만들어 보기 
1.파일을 복사하여 사본을 보관되어있음
2.원본파일이 없어진 경우 복사해놓은 사본을 원본 위치로 복사대상
3.diff 명령어를 사용하여 파일의 변경내용을 확인
4. 변경사항 발생시 알림 발생
cp, diff사용
----------------------------------------------------------------------------------------
#! /bin/bash

if [ -e /home/user/test ]
then
echo "<file exist>"
else
echo "<restore file>"
cp /home/user/test.bak /home/user/test
fi

diff=$(diff /home/user/test /home/user/test.bak)

if [ -n "${diff}" ]
then
echo "<filechanged>"
echo $diff
else
echo "-equal-"
fi
---------------------------------------------------------------------------------------
#! /bin/bash
read -p "filename : " test
read -p "Do you want crate backup file ? : " conf
if [ $conf = y ]
then
cp /home/user/$test /home/user/${test}.bak
echo "copy complite!"
fi


if [ -e /home/user/$test ]
then
echo "<file exist>"
else
echo "<restore file>"
cp /home/user/${test}.bak /home/user/$test
exit 0
fi

diff=$(diff /home/user/${test} /home/user/${test}.bak)

if [ -n "${diff}" ]
then
echo "<filechanged>"
echo $diff
else
echo "-equal-"
fi
-----------------------------------------------------------------------------------
if test $# -eq 0; then > argument의 개수가 0개이면 then
echo "you must supply one arg" >&2
        exit 1
fi
echo "EOP"
-------------------------------------------------------------------
스크립트 옵션 file
- 첫번째 arg 를 -v 옵션을 사용하여 실행하면 less 명령어로 file을 확인할수 있도록 코딩
- -v옵션을 사용하지 않는경우 cat 명령어를 통해서 file을 확인할수 있도록 코딩

./test.sh
-> arg가 없습니다.

./test.sh -v filea
-> less 명령어로 filea를 실행

./test.sh filea
-> cat 명령어로 filea를 실행

--------------------------------------------------------
#! /bin/bash
if test $# -eq 0; then
echo "no option"
exit 1
fi

if [ "$1" = -v ]
then
less "$2"

else
cat "$1"
fi

or

! /bin/bash
if test $# -eq 0; then  > 실행하는 쉘스크립트 뒤에 argument가 없다면 참 
echo "no option"
exit 1
fi


if [ "$1" = -v ]
then
shift
less "$@"

else
cat "$@" 
fi
--------------------------------------------------
쉘스크립트에서의 $1, $2, $@ (위치 매개 변수)

#! /bin/bash
echo $1
echo $2         # 각각 1,2,3 번째 위치 파라미터를 표기
echo $3
echo $@      #모든 위치파라미터를 표기
echo $#      # 위치파라미터의 개수를 표기
echo $*        #  $@ 와 동일함

sh shell.sh 1 2 3 4 5
1        
2        
3        
1 2 3 4 5
5

*띄어쓰기 있어야 구분함
---------------------------------------------

-case-
test string d이 패턴과 일치하면 해당 패턴 이후의 커맨드를 실행
;; (세미콜론 두개) 를 통해 제어권 종료

case test-string in
        pattern-1)
        command1
        ;;
        pattern-2)
        command2
        ;
        pattern-3)
        command3
        ;;
        *)
        command4
        ;;
esac

* : 임의의 모든 문자열 (패턴에 일치하는것 제외함)
? : 임의의 한글자 문자열
[...] 문자 클래스 . 한글자씩일치하는지 여부를 확인(and연산)
ex) [ABC]
| : or연산, 분리조건을 이용함

read -p "A,B,C: " letter
case "$letter" in
    A|a)
        echo "you enter A"
        ;;
    B|b)
        echo "you enter B"
        ;;
    C|c)
        echo "you enter C"
        ;;
    *) 
        echo "you not enter ABC"    
esac

-----------------------------------------------------------------
계산기 만들기
사칙연산에 expr 사용

#! /bin/bash
read -p "enter A : " A
read -p "enter B : " B
read -p " select operator  1)+  2)-  3)*  4)/ " select
case $select in
        1|'+')
        echo `expr $A + $B`;;
        2|'-')
        echo `expr $A - $B`;;
        3|'*')
        echo `expr $A \* $B`;;
        4|'/')
        #echo `expr $A / $B`;; 소수점 계산 불가능
         echo "$A $B"| awk '{printf"%.3f",$1 / $2}' && echo ;; 
        *)
        echo "wrong answer";;
esac
----------------------------------------------------------------------
반복문 (for)
for <loop-index> in <argument-list>
do
        command
done

ex)
#! /bin/bash

for i in apple orange peach banana
        do
                echo "$i"
done
--------------------------------------------------------------
for i in {1..10..1}
        do
                echo "$i"
done
---------------------------------------------------------------
for i in * 
# * : 현재작업디렉토리에 있는 모든파일이름을 말한다( 숨김파일제외)
        do
                echo"$i"
done
ex)
#! /bin/bash

for i in *
do
        if [ -d $i ]; then
        echo -e "\E[0;43m $i is Directory \E[0m"
        elif [ -f $i ]; then
        echo -e "\E[0;42m $i is File \E[0m"
        fi
done
----------------------------------------------------------------------------------------------------------

C 스타일루프
count를통한 단순 반복루프

for~~ in ~~
>
for (( varuable 할당; condition ; iteration process ))

for (( x=1; x<=10; x=x+1 ))
do
        command
done

for (( x=1; x<=10; x=x+1 )) = for (( x=1; x<=10; x+=1 )) = for (( x=1; x<=10; x++ ))

--------------------------------------------------------------------------------------------------------
for (( x=1, y=10; x<=10; x+=1, y-- ))
        do
        echo "x =  $x"
        echo "y =  $y"
        done

--------------------------------------------------------------------------------------------------------
파일 이름을 일괄변경하는 프로그램
현재 디렉토리에서 지정된 파일둘의 확장자를 일괄변경
동일한 확장자를 가진 파일 확인
확장자를 일괄변경
ex)
변경을 원하는 확장자 : txt
변경후 확장자 : xtx


read -p "변경을 원하는 확장자 : " a1
read -p "변경후 확장자 : " a2

for i in  *
do

t=$(basename ${i} ${a1})
if [ $i = "${t}${a1}" ]
then
mv $i ${t}${a2}
changed=${t}${a2}
ls -l ${changed}
fi
done
---------------------------------------------------------------------------------------
* #! /bin/bash 는 생략가능함

${변수명#삭제문자}    => 시작지점을 포함하여 가장 짧게 매칭되는 패턴 삭제
${변수명##삭제문자}    => 시작지점을 포함하여 가장 길게 매칭되는 패턴 삭제
${변수명%삭제문자}    => 끝지점을 포함하여 가장 짧게 매칭되는 패턴 삭제
${변수명%%삭제문자}    => 끝지점을 포함하여 가장 길게 매칭되는 패턴 삭제
${#변수명} =>변수길이 

-------------------------------------------------------------------------------------------
while 
-if ~then 과 for문 사이에 있음
-test command를 정의한다음 test command가 종료상태를 false를 돌려줄때 까지 커맨드를 반복
(testcommand가 true일때는 반복하고 false인경우 종료)

기본형태
while test-command 
do
        command
done

ex)
var1=10
while [ $var1 -gt 0 ]
do
echo "this is test $var1"
var1=$[ var1 - 1 ]
sleep 1
done

조건문에서의 옵션사용 ( 정수일경우에만 사용가능)
-ne : not equal
-eq : equal
-gt : grater than
-ge : grater than or equal
-lt : less then
-le : less then or equal

-while은 조건문을 만나야만 동작여부를 결정한다.
var1=10
while echo $var1
        [ $var1 -ge 0 ]
do
echo "this is test $var1"
var1=$[ var1 - 1 ]
sleep 1
done

> echo $var1 이 조건문위에있으므로 -1까지 나오게된다.

for문과 while문의 차이점
for :  argumnet list가 존재해서 하나씩 추출하여 반복 (반복시킬 횟수를정해두고 그만큼을 반복)
while : testcommand가 존재하여 true면 반복 , false면 중지 ( 원하는 결과값이  나올때까지 반복)

실습
시스템 상태를 체크하는 프로그램 작성
주기적으로 시스템 상태를 확인해 파일에 저장하는 프로그램을 코딩
결과를 실행시간에 따른 파일이름으로 저장하시오
ex) 20210317104130 .logh 간격은 30초 
메모리상태, 프로세스 상태, 디스크 상태를 기록 
free  ps  dh -Th

------------------------------------------------------------------
while [ true ]
do
var1=$(date '+%Y%m%d%H%M%S')
touch /home/user/timelog/${var1}.log
echo " $var1 logfile create"
free >> /home/user/timelog/${var1}.log
ps -ef>> /home/user/timelog/${var1}.log
df -Th >> /home/user/timelog/${var1}.log
sleep 30
done
-----------------------------------------------------------------
until
-while 과 형태는 같으나 정 반대로 동작
 기본형
 until testcommand
 do 
        command
done

while과의 차이점
while : testcommand > true > 반복 > false > 종료
until : testcommand > false > 반복 > true > 종료

실습
untill을 사용
name이라는 변수 지정
name 변수와 맞으면 탈출 그렇지않으면 변수를 입력받는 게임을 만드시오
----------------------------------------------------------------------------------
echo  'what is "name"? '
read pswd
until [ $pswd = "ciw0707" ]
do
echo -e "\E[0;31mwrong answer! \E[0m" 
echo  'what is "name"?' 
read pswd
done
echo -e "\E[0;32mcollect! \E[0m" 
-----------------------------------------------------------------------------------
ctrl +z  : vi 편집기에서 쉘로 나가기 (명령어 fg로 복귀)
or 입력모드에서 sh입력 (ctrl +d 로 복귀)

---------------------------------------------------------------------------------
중첩반복문
-반복문 안에 반복문 넣기

ex) for ~ for
for (( a=1; a<=3; a++ ))
do 
        for (( b=1; b<=10; b++ ))
                do
                echo "a=$a : inside loop : b=$b"
                done
done

실습 
1. 구구단 계산기 ( 1단부터 시작 n 단 까지 계산 n:입력)
ex) 몇단까지 계산하겠습니까? 5
        1~5단까지 계산
--------------------------------------------------------------------
read -p "몇단까지 계산하시겠습니까 ? : " a
var1=1
while [ $a -ge $var1 ]
do
echo "$var1 단" 
        for (( b=1; b<=9; b++ ))
                do
                echo "$var1 * $b = `expr $var1 \* $b`"
                done
var1=$[var1+1]
done
-------------------------------------------------------------------

2. 디렉토리생성프로그램 
dir1,dir2,dir3,dir4를 생성하고 
        각각의 디렉토리에 subdir1 subdir2 subdir3 subdir4 subdir5

-----------------------------------------------------------------------------
for i in dir1 dir2 dir3 dir4
do
echo "$i를 생성합니다"
mkdir $i
        for f in subdir1 subdir2 subdir3 subdir4 subdir5
                do
                echo " $i/$f 를 생성합니다"
                mkdir $i/$f
                done
done
--------------------------------------------------------------------------------
> 가로로 구구단 출력
#! /bin/bash
for i in {1..9}
do
        for f in {1..9}
        do
        echo -ne "$f*$i = `expr $f \* $i`\t"
        done
echo ""
done

----------------------------------------------------------------------
while [         ]
do
        for ((          ))
        do
        done
done

*참고 서적"처음부터 배우는 쉘스크립트"

------------------------------------------------------------------------------------------------
break
진행중인 루프에서 탈출
exit > 완전종료
break >루프에서만 탈출

ex)
#! /bin/bash

for var1 in {0..10}
do
        if [ $var1 -eq 5 ]; then
        break
        fi
echo "iter num : $var1"
done
echo " loop complete"

------------------------------------------------------------
#! /bin/bash

for var1 in {0..10..2}
do
        if [ $var1 -eq 5 ]
        then
        break
        fi
        echo "iter num : $var1"
done
echo " loop complete"
#>  break 실행 x (if의 조건문에 걸리지않는다 )
-------------------------------------------------------------------------------
#! /bin/bash

for var1 in {0..10..2}
do
        if [ $var1 -eq 5 ]
        then
        exit
        fi
        echo "iter num : $var1"
done
echo " loop complete"
#> exit를 사용하면 바로 쉘이 종료되어 echo가 실행되지않는다
----------------------------------------------------
중첩반복문으로 작업할때 break 명령은 자동으로 가장 안쪽에있는 루프를 종료시킨다.
ex)
for (( a=1; a<=10; a++ ))
do
        echo " a 값은 $a "
        for (( b=1; b<=100; b++ ))
        do
                if [ $b -eq 5 ]; then
                break
                fi
        echo "b 값은  $b"
        done
done
--------------------------------------------------------------------------------------------
루프의 단계
break n (n : 빠져나갈수있는 루프의 단계를 나타낸다)
1: 현재루프
2: 한단계위의 바깥쪽 루프를 나타낸다
ex)
for (( a=1; a<=10; a++ ))
do
        echo " a 값은 $a "
        for (( b=1; b<=100; b++ ))
        do
                if [ $b -eq 5 ]; then
                break 2
                fi
        echo "b 값은  $b"
        done
done
#>if 조건이 만족되면 첫번째 for 구문이 멈추게된다 
----------------------------------------------------------------------------
Continue(skip)
-중지와 연관된 예약어
-반복문의 위의 상태로 이동시켜준다
-continue를 만나게되면 현재 실행해야할 반복문을 실행하지않고,
 그다음 조건에 맞추어서 반복문을 실행하게되는것

ex)
반복문 >> 종료 
(반복문 >> exit)
반복문 >> break > 반복문이 종료됨 >  다음 코드를 실행
반복문 ------------------>  Continue 
        └------<-------------┘

#! /bin/bash
for (( var1=1; var1<15; var1++))
do
        if [ $var1 -gt 5 ] && [ $var1 -lt 10 ]; then
                continue
        fi
        echo " iteration num : $var1 "
done
----------------------------------------------------------------------------
continue  n (n : 재시작할 루프의 수준을 정의해준다)
for (( a=1; a<=5; a++ ))
do
        echo " $a"
        for (( b=1; b<=5; b++ ))
        do
                if [ $b -eq 3 ]
                then
                        continue 2
                fi
                var3=$[$a*$b]
                echo " result $a*$b=$var3"
        done

-------------------------------------------------------------------------
루프의 출력
#! /bin/bash
for
do
done > output.txt

-파이프 라인을 통해 다른 명령어로 전달가능
for
do
done  | sort 
            grep 

- 반복문
환경변수 $PATH에 저장된 디렉토리를 검사하여 실행 파일이 있는 파일들을
나열하는 프로그램을 만드시오.

 1. IFS ????
 2. test command 실행파일임을 검사하는 command??? 


IFS=:
for folder in $PATH
    do 
        for file in $folder????
            if [ -x $file ]; then
                echo "      $file"
            fi
    done

    엑셀파일을 통해서 계정생성프로그램 만들기

    excel 파일
    user.csv
    apollo,myoh
    aaa,ddd
    qqqq,eeeee
    (엑셀에서는 구분자가 , 이므로 IPS를  , 으로 변경)
    
input="user.csv"
while
IFS=','
    read -r userhome comment
    do
        echo "계정생성"
        useradd -m $userhome -c $comment
done  < "$input"
---------------------------------------------------------------
함수 function

1. function name {
        command
}
2. name ( ) {
        command
}

ex)
#! /bin/bash
function func1 {
        echo " thisis example"
} 
func1
# > 함수를 선언한뒤에 호출해야만 작동함
만약 선언전에 호출하게되면 작동하지않는다.
--------------------------------------------------------------------------------
#! /bin/bash
function func1 {
echo "this is example"
}

count=1
while [ $count -le 5 ]
do
        func1
        count=$[ $count +1 ]
done
echo " loopend"
func1
echo "EOP"
-----------------------------------------------------------------------------------

함수는 중복되어 정의되면 마지막에 정의된내용으로 덮어쓰이게된다 (변수와 동일함)

return
함수의 종료상태를 되돌려 줄수 있는 명령어
0~255까지의 정수로만 가능함
ex)
function func1 {
        read -p "var1 : " var1
        echo "$var1*2"

        return $[ $var1 * 2 ]

}
func1
echo $?
---------------------------------------------------------

함수에서 변수 사용하기
- bash쉘에서 함수는 미니 스크립트와 같이 다뤄진다. 함수도 비슷하게 매개변수를 전달 받을수 있다.
- $0 : 함수, $1 : arg1, $2 : arg2, ...  으로 정의 된다
- $# 

[root@localhost day5]# cat func6.sh
#!/bin/bash
function add1 {
    if [ $# -eq 0 ] || [ $# -gt 2 ]; then
#        echo -1
        return 0
    elif [ $# -eq 1 ]; then
        result=$[ $1 + $1 ]
#       echo "$result"
        return $result
    else
        result=$[ $1 + $2 ]
#       echo "$result"
        return $result
    fi
}
echo "------------------------------"
echo "arg1:10, arg2:20"
add1 10 20
value=$?
echo $value

echo "------------------------------"
echo "arg1:10"
add1 10
value=$?
echo $value

echo "------------------------------"
echo "arg none"
add1
value=$?
echo $value


[root@localhost day5]# cat func5.sh
#!/bin/bash
function add1 {
    if [ $# -eq 0 ] || [ $# -gt 2 ]; then
        echo -1
    elif [ $# -eq 1 ]; then
        echo $[ $1 + $1 ]
    else
        echo $[ $1 + $2 ]
    fi
}
echo "------------------------------"
echo "arg1:10, arg2:20"
value=$(add1 10 20)
echo $value

echo "------------------------------"
echo "arg1:10"
value=$(add1 10)
echo $value

echo "------------------------------"
echo "arg none"
value=$(add1)
echo $value

-------------------------------------------------------------------
[root@localhost day5]# vim func7.sh
[root@localhost day5]# [root@localhost day5]# cat func7.sh
#!/bin/bash
function func1 {
    echo $[ $1 * $2 ]
}

if [ $# -eq 2 ]; then
    value=$(func1 $1 $2)
    echo "result $value"
else
    echo "need value"
fi

[root@localhost day5]# ./func7.sh 10 20
result 200
------------------------------------------------------------------

변수의 범위 (scope)

두가지 종류의 변수를 사용한다.
1. 전역변수(global) : 쉘스크립트 내부 어디에서나 사용할수 있는 변수
기본적으로 스크립트에서 정의한 모든 변수는 전역변수이다.
함수 외부에서 정의 된 변수 , 함수외부에서도 사용가능하다.
ex)
function func1 {
        val1=$[ $val1 * 2 ]
}

read -p " value :? " val1
func1
val1=$[ val1 -1 ]
echo $val1 
#> 함수 밖에서 연산도 가능함


2. 지역변수 (local ) 변수
함수에서 전역변수를 사용하는 대신 함수안에있는 모든 변수를
함수안에서만 사용하는 변수로 선언
local이라는 키워드를 사용함

#!/bin/bash
function func1 {
        local temp=$[val1 +5]
        result=$[temp *2]
}

temp=4
val1=6
func1
echo $temp
echo $val1
echo $result

if [ $temp -gt $val1 ]; then
echo " temp > val1"
else
echo " val1 > temp"
fi
#> local 키워드를 사용해서 지역변수로 선언, 함수에서만 temp값이 변화하고 함수 밖에는 영향을 주지않는다.

------------------------------------------------------------------------------------------------
재귀함수
자신을 정의 할 때 자기자신을 재참조하는 방법을 뜻함
알고리즘의 마지막을 정의 해줘야 한다.
function factorial {
    if [ $1 -eq 1 ]; then
        echo 1
    else
        local temp=$[ $1 - 1 ]
        local result=$(factorial $temp)
        echo $[ $1 * $result ]
    fi
}

read -p "enter val: " value
result=$(factorial $value)
echo "$value factorial is : $result" 

-----------------------------------------------------------
라이브러리

필요한 함수들을 저장해두고 필요할떄마다 import해서 사용함
쉘 내부에 서는 다른스크립트를 실행이 가능함 
./xxx.sh : 쉘스크립트를 실행하고 메모리에 올라가지는않고 끝남 ( 불러온 쉘스크립트내의 함수를 사용 불가능)
( 쉘안에 새로운 쉘을 실행시킴)
. ./xxx.sh  : (=source ./xxx.sh)쉘스크립트를 실행하고 메모리에 올림 ( 불러온 쉘스크립트내의 함수를 사용 가능)
(현재 쉘안에서  명령을 실행)
ex)
$ vim 1.sh
function add {
        echo $[ $1 + $2]
}
echo "hi 1.sh"

$ vim 2.sh
./1.sh
#. ./1.sh 
echo $( add 10 20 ) 
#첫번째 줄과 두번째 줄의 주석처리를 바꾸어가면서 확인
------------------------------------------------------------------------------------------
sed  편집기 
-일반적인 대화형 텍스트 편집기와는 반대개념인 스트림 방식의 편집기
-스트림 방식 : 데이터를 처리하기전에 데이터 처리 형식을 입력받고 그 형식에 따라서 처리하는 방식

동작방식 
1. 한번에 데이터 한줄씩을 읽는다.
2. 읽은 데이터를 규칙과 대조
3. 명령에서 지정된 규칙에 따라 스트림의 형식으로 변경한다.
4.  STDOUT으로 출력(파일 자체는 바뀌지않는다 *-i 옵션을 쓰면 실제 파일 변경가능)
ex ) sed 's/nologin/hello/; s/sbin/abin/' passwd 

awk 편잽기
gawk : 유닉스 awk 편집기의 GNU버전 
sed 편집기보다 더 나은 편집환경을 제공한다.
1. 데이터를 저장하는 변수 정의가능
2. 산술 문자열 연산가능
3. loop , if-then같은 로직을 추가가능

기본형태
STDOUT | gawk 'pattern' 
gawk 'pattern' file
gawk '{action}' file
gawk 'pattern {action}' file
특이사항
스크립트는 괄호로 정의한다.

mary 패턴이 포함된 줄을 출력
gawk '/mary/' data  : data파일에서 mary라는 패턴을가진 데이터 출력
gawk '{print $1}' data : data파일에서 1번째 필드 데이터 출력
 gawk '/sally/ {print $1}' data :  data파일의 1번째 필드에서  mary라는 패턴을가진 데이터 출력
gawk '/sally/ {print $1,$2}' data : data파일에서 mary라는 패턴을가진 데이터를 1,2번필드 까지 출력

df | gawk '$4>=1881964' 4번째 필드가 1881964보다 큰값을 출력

'/ xxx/' 정규표현식 문법을 사용할때 / /사용
cat passwd | gawk '/nologin$/' 
cat passwd | gawk '/^mail/'

------------------------------------------------------------------------------------
awk 의 동작원리
1. 입력된 줄에 $0라는 내부변수에 그줄을 넣는다 (줄을 읽을때마다 그 줄을 $0에 할당시킴)
각 줄은 레코드라고 부르기도한다.(개행 문자를 통해서 레코드를  구분)

2. 각줄은 공백으로 구분된 필드로 쪼개어 진다.
필드는 $1으로 시작되는 숫자 변수에 저장

3.gawk 는 FS라는 변수에 공백을 구분하는 변수를 할당한다 (기본값은 space)

*필드와 레코드 분리변수
FILEDWIDTHS : 데이터 필드의 정확한 폭을 정의
FS : 입력필드 구분 (커맨드라인  -F) ex) gawk 'BEGIN{FS=","}{print $1}' data3
RS : 입력 레코드 구분
OFS : 출력 필드 구분 ex) gawk 'BEGIN{FS=","; OFS="/";} {print $1,$2;}' data3
ORS : 출력 레코드 구분

BEGIN 을 통해서 FS,OFS 등을 지정할수 있다.
형식 : BEGIN{FS="," OFS="-"}


4.gawk 가 필드를 출력할때 action에서 print라는 함수를 사용함
-OFS변수에 다른값을 할당하면 출력시 공백이 아닌 다른 문자로 필드를 구분
ex) cat passwd | gawk -F: '{print $1}' passwd

5.gawk가 결과를 출력한후, 다음줄을 갖고온다 (반복)

$0 :텍스트 전체
$1 : 텍스트 줄에서 첫번째 데이터 필드
$n : 텍스트 줄에서 n번째 데이터 필드

세미콜론을 이용하면 여러 명령 동시에 호출가능
gawk -F : '{$1="apollo" ; print $1,$2 }' passwd 

파일을  이용한 호출

vim script
{ print $1" 's home d is" $6 }

gawk -F : -f script passwd

awk 정규 표현식 메타문자
^
$
.
* : 선행문자와 같은 문자의 0개 혹은 임의개 대응
? : 선행문자와 같은 문자의 1개 와 대응
+ :
[ABC]
[^ABC]
[A-Z]
A|B

[ABC]? : [ABC][ABC] 또는 [ABC]
[ABC]+ : [ABC][ABC] 또는 [ABC][ABC][ABC]


match 연산자
(~) : 레코드나 필드내에서 일치하는 패턴을 찾음
 gawk '$1 !~ /ly$/' data > 첫번째 필드가 ly로 끝나지않는 패턴만을 출력

 예제) 
 ex1.txt
 1. west 라는 글이 있는 줄 출력  gawk '/west/' data4
 2.gawk '/^north/' data4
 3.gawk '/^[no,so]/' data4
 4.gawk '{OFS=" "}{print $2,$3}' data4
 5.gawk '{OFS=""}{print $2,$3}' data4\
 6.gawk '/^[n,s]/{print $1}' data4
 7.gawk '$5 ~/\.[7-9]$/' data4
 8.gawk '$2 !~/E/{print $1,$2}' data4
 9.gawk '$3 ~/^Joel/{print $3" is a nice guy"}' data4
 10.gawk '$8 ~/../ {print $8}' data4
11.gawk '$4 ~/Chin$/ {print "The price is $"$8"."}' data4

 예제)
  ex2.txt
gawk -F':' '$7 ~ /^5/{print $7}' ex2
gawk -F':' '$2 ~ /CT/ {print $1, $2}' ex2
gawk -F':' '$7<5 {print $4, $7}' ex2
gawk -F':' '$5>.9  {print $1,$6}' ex2

리눅스 강의에서 빠진것들
정규표현식
DB(mysql/sql) 쿼리 
웹서버 HAproxy
VNC
PXE 
SAN 
웹서비스 구성(워드프레스0. html+django(x)
awk기초만
bc 

웨비나 등록(인프라 오픈채팅)


bc :bash calculator
test=$(echo "scale=2; 3.2 / 2" | bc )
echo $test
1.60

---------------------------------------------------------------
-보충수업내용

$? : 리눅스 결과 코드 출력 (0: 정상실행)

-주석처리 
# 한 줄 주석

:<<'END'
여러줄
주석
END


-------------------------------------------------------
PS3="Select the number : "

select test in date pwd 'ping 8.8.8.8 -c 3' exit
do
        $test

done
----------------------------------------------------

*break


-select 와 case를 이용하여 특정위치로 ping 가능여부 확인하시오

1) 구글  2)네이버  3)다음  4)종료
선택하세요 : 1

ping www.google.com -c 5


PS3="Select the number : "


select test in google naver daum exit
do
case $test in
        google)
        test='ping www.google.com -c 5'
        ;;
        naver)
        test='ping www.naver.com -c 5'
        ;;
        daum)
        test='ping www.daum.net -c 5'
        ;;
        exit)
        test='exit'
        ;;
        esac
        $test
done
